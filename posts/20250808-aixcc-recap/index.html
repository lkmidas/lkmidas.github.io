<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Two-year Recap: A Story of 42-b3yond-6ug and AIxCC - Midas&#39;s Blog</title><meta name="Description" content="Recaps, thoughts, and reflects on me and my team&#39;s AIxCC journey"><meta property="og:title" content="Two-year Recap: A Story of 42-b3yond-6ug and AIxCC" />
<meta property="og:description" content="Recaps, thoughts, and reflects on me and my team&#39;s AIxCC journey" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lkmidas.github.io/posts/20250808-aixcc-recap/" /><meta property="og:image" content="https://lkmidas.github.io/images/avatar.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-08-07T22:18:43-07:00" />
<meta property="article:modified_time" content="2025-08-07T22:18:43-07:00" /><meta property="og:site_name" content="My cool site" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://lkmidas.github.io/images/avatar.png"/>

<meta name="twitter:title" content="Two-year Recap: A Story of 42-b3yond-6ug and AIxCC"/>
<meta name="twitter:description" content="Recaps, thoughts, and reflects on me and my team&#39;s AIxCC journey"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://lkmidas.github.io/posts/20250808-aixcc-recap/" /><link rel="prev" href="https://lkmidas.github.io/posts/20230828-sekaictf2023-writeups/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Two-year Recap: A Story of 42-b3yond-6ug and AIxCC",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/lkmidas.github.io\/posts\/20250808-aixcc-recap\/"
        },"genre": "posts","wordcount":  6601 ,
        "url": "https:\/\/lkmidas.github.io\/posts\/20250808-aixcc-recap\/","datePublished": "2025-08-07T22:18:43-07:00","dateModified": "2025-08-07T22:18:43-07:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Midas"
            },"description": "Recaps, thoughts, and reflects on me and my team's AIxCC journey"
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Midas&#39;s Blog"><span class="header-title-pre"><i class='fas fa-home'></i></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Midas&#39;s Blog"><span class="header-title-pre"><i class='fas fa-home'></i></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Two-year Recap: A Story of 42-b3yond-6ug and AIxCC</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Midas</a></span>&nbsp;<span class="post-category">included in <a href="/categories/ai/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>AI</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2025-08-07">2025-08-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;6601 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;31 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#forewords">Forewords</a></li>
    <li><a href="#what-is-aixcc">What is AIxCC?</a>
      <ul>
        <li><a href="#competition-overview">Competition Overview</a></li>
        <li><a href="#afc-technical-details">AFC Technical Details</a></li>
        <li><a href="#scoring-overview">Scoring Overview</a></li>
      </ul>
    </li>
    <li><a href="#about-42-b3yond-6ug">About 42-b3yond-6ug</a>
      <ul>
        <li><a href="#our-team">Our Team</a></li>
        <li><a href="#asc-quick-recap">ASC Quick Recap</a></li>
        <li><a href="#our-mindset">Our Mindset</a></li>
        <li><a href="#our-crs">Our CRS</a></li>
        <li><a href="#the-experience">The Experience</a></li>
        <li><a href="#testing">Testing</a></li>
      </ul>
    </li>
    <li><a href="#peeking-into-other-teams-crss">Peeking into other Teams&rsquo; CRSs</a>
      <ul>
        <li><a href="#categories-of-crss">Categories of CRSs</a></li>
        <li><a href="#trail-of-bits---buttercup">Trail of Bits - ButterCup</a></li>
        <li><a href="#lacrosse">Lacrosse</a></li>
        <li><a href="#shellphish---artiphishell">Shellphish - Artiphishell</a></li>
        <li><a href="#team-atlanta---atlantis">Team Atlanta - Atlantis</a></li>
        <li><a href="#theori---roboduck">Theori - RoboDuck</a></li>
        <li><a href="#all-you-need-is-a-fuzzing-brain">All You Need Is A Fuzzing Brain</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><div class="details admonition note open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw" aria-hidden="true"></i>Note<i class="details-icon fas fa-angle-right fa-fw" aria-hidden="true"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><em>Use the table of contents on the right to navigate to the section that you are interested in.</em></div>
        </div>
    </div>
<h2 id="forewords">Forewords</h2>
<p>Well, it&rsquo;s been 2 years since I last updated my blog. Time sure does fly. A few days ago, I couldn&rsquo;t even recall how to make a new post and update this blog!</p>
<p>Anyhow, regarding what I&rsquo;ve been doing the last 2 years - you might&rsquo;ve heard about a HUGE competition organized by DARPA and ARPA-H, called the <a href="https://aicyberchallenge.com/" target="_blank" rel="noopener noreffer "><strong>AI Cyber Challenge</strong></a>, or <strong>AIxCC</strong>. It&rsquo;s a 2-year-long competition that I participated in as a core member of my wonderful team, <a href="https://b3yond.org/" target="_blank" rel="noopener noreffer "><strong>42-b3yond-6ug</strong></a>. It was a great experience with ups and downs, challenges and triumphs. We pretty much abandoned many things - like CTFs, coursework, and even research projects - to focus all of our efforts on this competition. That said, now that the competition is officially over, I have the itch to start writing something again!</p>
<p>So with this post, I just want to write whatever comes to mind about my team&rsquo;s and my own journey in AIxCC, looking back. I&rsquo;d probably only describe things at a very high-level 10,000-foot view here, but do expect full technical writeups about our team&rsquo;s system later on our team&rsquo;s blog.</p>
<p>With all that out of the way, let&rsquo;s get into it!</p>
<h2 id="what-is-aixcc">What is AIxCC?</h2>
<h3 id="competition-overview">Competition Overview</h3>
<p>AIxCC is a large-scale competition organized by <strong>DARPA</strong> and <strong>ARPA-H</strong> that tries to bridge the gap between rapidly emerging AI technologies and cybersecurity. From the official site:</p>
<blockquote>
<p>&ldquo;The Artificial Intelligence Cyber Challenge (AIxCC) is a two-year competition that brings together the best and brightest in AI and cybersecurity to safeguard the software critical to Americans. AIxCC competitors are designing, testing, and improving novel AI systems to automatically secure this critical code. Cumulative prizes total $29.5 million to teams with the best systems.&rdquo;</p>
</blockquote>
<p>So, in shorter and simpler terms, the competition is about embracing AI to build an autonomous system that can secure code - and win BIG money. &ldquo;Securing code&rdquo; here means finding vulnerabilities and fixing them.</p>
<p>The 2-year timeline of AIxCC was roughly this:</p>
<ol>
<li>The competition was announced at Black Hat USA, August 2023.</li>
<li>Open Track and Small Business Track registration and proposal.</li>
<li>Small Business Track winners announced in March 2024 (7 teams).</li>
<li>Preliminary events leading to the AIxCC Semifinal Competition (ASC).</li>
<li>The ASC at DEFCON 32, August 2024, announcing 7 winning teams.</li>
<li>Three exhibition rounds leading to the AIxCC Final Competition (AFC).</li>
<li>The AFC announcement at DEFCON 33, August 2025, announcing the top 3 winners.</li>
</ol>
<p>I&rsquo;ll mostly only talk about the AFC in this post, since I personally feel like I learned the most and had the best experiences during the second year of development leading to the Finals. I believe both our system and the competition infrastructure weren&rsquo;t mature enough at the time of the ASC and earlier, and the infrastructure was quite different.</p>
<p>That being said, our team 42-b3yond-6ug did win the Small Business Track prize and the ASC, which are great achievements in and of themselves.</p>
<h3 id="afc-technical-details">AFC Technical Details</h3>
<p>In this competition, each team is expected to build a Cyber Reasoning System (CRS) that can autonomously identify vulnerabilities in real-world projects&rsquo; codebases and fix them accordingly - <strong>without</strong> human intervention. During a competition round, there are <strong>only two</strong> entities interacting with each other: the competition API sending the tasks, and the CRS&rsquo;s API receiving and processing the tasks. Each team is given a large amount of budget per round (5 figures!) for compute resources and LLM usage to deploy their CRS.</p>
<p>In the AFC, there are three unscored exhibition rounds and one final scored round. For each round, the CRS must be running and handling tasks at all times for several days - up to 10 days in the final round. The tasks are called <strong>Challenge Projects (CPs)</strong>, which are real-world projects (such as libpng, libxml2, Apache, etc.), with or without synthetic vulnerabilities, that are compatible with the OSS-Fuzz infrastructure.</p>
<p>At the beginning of AIxCC in 2023, the organizers were very ambitious with the variety of CPs that teams were expected to deal with, including projects written in many different programming languages. However, after many considerations and rounds of feedback, the ASC narrowed the scope down to just C and Java user space projects, as well as the Linux kernel. In the AFC, the kernel was also removed, leaving only C and Java OSS-Fuzz-compatible projects. That&rsquo;s not to say the scope became small - in fact, the CRS had to handle a total of <strong>60 tasks across 30 different projects</strong> in the final round, with a budget of <strong>$85,000 in Azure compute resources</strong> and <strong>$50,000 in LLM usage</strong>.</p>
<p>There are two types of tasks that the CRS is expected to handle:</p>
<ol>
<li><strong>Full-scan</strong> tasks: The CRS receives two tarballs - one containing the CP&rsquo;s source codebase, and another containing the OSS-Fuzz tooling used to build and run that codebase. For a full-scan task, <em>any</em> vulnerability found in the codebase is eligible for scoring.</li>
<li><strong>Delta-scan</strong> tasks: In addition to the codebase and fuzz tooling, the CRS also receives a DIFF file for the codebase. For a delta-scan task, only vulnerabilities introduced in the DIFF - or vulnerabilities that were already in the codebase but became <em>reachable</em> after the DIFF was applied - are eligible for scoring.</li>
<li>In addition, during the timeline of any given task, a <strong>SARIF report</strong> might be sent to the CRS. SARIF is a standardized format for representing static analysis results - e.g., which area of code contains a bug, what type of bug it is, etc. The CRS can respond with whether the SARIF report is a true positive to earn points.</li>
</ol>
<p>One thing to note is that <strong>all</strong> challenge tasks and CRSs will be <strong>open-sourced</strong> at some point after the competition is over - which to me is super hyped. I can&rsquo;t wait to show the world what we&rsquo;ve achieved, to learn in detail what other teams have cooked up, and the challenge tasks could be refactored into a really nice benchmark dataset as well.</p>
<h3 id="scoring-overview">Scoring Overview</h3>
<p>The scoring algorithm is quite complex - as it should be - to ensure that all scenarios are accounted for and scored appropriately. The official scoring guide that we received in the end was super long (40 pages!), but here, I&rsquo;ll just list the key points:</p>
<ul>
<li>There are 4 types of scorable submissions that the CRSs can submit to the competition API: Proofs-of-Vulnerability (PoVs), Patches, SARIF Assessments, and Bundles.</li>
<li>For the purpose of this competition, any input that triggers a crash in the target project is considered a <strong>PoV</strong>. This includes sanitizer crashes (such as ASAN, MSAN, UBSAN, etc. for C projects, and JAZZER for Java), as well as libFuzzer crashes, such as timeouts and out-of-memory. (libFuzzer is the default fuzzer in OSS-Fuzz.) Each correct PoV is worth 2 points, or 0 points otherwise.</li>
<li>A <strong>Patch</strong> is a DIFF file that can be applied to the CP&rsquo;s codebase to mitigate one or more vulnerabilities. Patches are assessed manually by the organizer using the ground truth PoV, and all variant PoVs of the same bug submitted by <strong>all teams</strong>. This means that even if a patch can prevent your team&rsquo;s PoV from crashing the CP, it might still not be a correct patch if other teams&rsquo; submitted PoVs can still crash it. Each correct patch is worth 5 points, or 0 points otherwise.</li>
<li>A <strong>SARIF Assessment</strong> is simply a binary answer - correct or incorrect - to assess whether the given SARIF report is a true positive or not. Each correct SARIF assessment is worth 1 point, or 0 points otherwise.</li>
<li>A <strong>Bundle</strong> is an association between PoVs, Patches, and SARIF Assessments, to gain bonus points. For example, if Patch A can mitigate PoV 1, teams can submit a bundle of (Patch A, PoV 1). However, an incorrect bundle will result in a <em>deduction</em> in points, so it&rsquo;s a risky bonus submission.</li>
<li>For each task, there is a global <strong>Accuracy Multiplier (AM)</strong> that affects the score of all types of submissions for that task. An unscorable submission (e.g., a PoV that doesn&rsquo;t crash, a patch that doesn&rsquo;t fix any vulns, etc.) will lower the AM. Interestingly, duplicated PoV submissions (e.g., 2 different PoVs that trigger the same bug) don&rsquo;t negatively affect the AM, but duplicated patch submissions (e.g., 2 patches that fix the same bug) do. This creates a <strong>gamesmanship</strong> element that caused us - and I believe many other teams as well - a whole lot of headaches to minimize AM penalty.</li>
<li>There is a <strong>Time Multiplier (TM)</strong> element as well. This simply means that during the timeline of a task, earlier submissions score more - from 100% of the points at minute 0, down to 50% at the end. Notably, in the case of duplications, only the <strong>final</strong> duplicate is scored, which means we still prefer not to submit duplicates, in the interest of TM.</li>
</ul>
<p>There are a bunch of other finer details about how the organizers do deduplication on PoVs and patches to prevent duplicated scoring and such. However, I won&rsquo;t dive into them here. To be honest, at this point, we aren&rsquo;t even 100% sure about their exact methods of doing so - but I believe the points I listed above are sufficient to understand the gist of the competition.</p>
<h2 id="about-42-b3yond-6ug">About 42-b3yond-6ug</h2>
<h3 id="our-team">Our Team</h3>
<p><a href="https://b3yond.org/" target="_blank" rel="noopener noreffer "><strong>42-b3yond-6ug</strong></a> is a collaborative team of students and professors from five universities, led by Northwestern University in partnership with the University of Waterloo, University of Utah, University of Colorado Boulder, and University of New Hampshire.</p>
<p>Our team&rsquo;s name pays homage to Douglas Adams&rsquo;s &ldquo;The Hitchhiker&rsquo;s Guide to the Galaxy,&rdquo; reflecting our mission to move beyond mere bug identification toward developing robust, practical solutions.</p>
<p>In the AFC, our team has about 15 members who worked full-time on our CRS. In addition, we also hire a few programmers in the industry with specific engineering experience to help us with some finer details.</p>
<p>As a core member of the team, during the ASC, I was responsible for performing static analysis on the Linux kernel fuzzing harnesses to generate structured input formats that could aid kernel fuzzing. However, in the AFC, since the kernel challenge was removed, I shifted focus to become a co-author of our seed generation component, the primary author of our triage and corpus grabber components (more about them later), the main tester of our CRS, and helped make decisions related to the structure and scaling of our CRS infrastructure.</p>
<h3 id="asc-quick-recap">ASC Quick Recap</h3>
<p>The ASC didn&rsquo;t have exhibition rounds leading up to the main event. All the CRSs were officially executed only once, with <strong>much lower</strong> budgets than the AFC (hundreds of times lower), live for 1 day at DEFCON 32. The ASC challenges consisted of 5 entire codebases from 2 userspace C projects (Nginx &amp; SQLite3), 2 Java projects (Jenkins &amp; Tika), and the Linux kernel. If I remember correctly, the challenges were given one after another and lasted for 4 hours each. According to the official writeups, there were a total of 59 synthetic vulnerabilities across the 5 projects, and collectively, all teams found 22 of them, patched 15, and one team (Team Atlanta) found a 0-day.</p>
<p>As for our CRS, it was a simple fixed 3-node system deployed as a Kubernetes cluster. The system consists of static analysis components, multiple fuzzers (AFL, Jazzer, Syzkaller), and an LLM Patch Agent. I don&rsquo;t have the exact number of bugs and patches that we found during the ASC anymore, but according to <a href="https://dashboard.aicyberchallenge.com/ascsummary" target="_blank" rel="noopener noreffer ">the official summary</a>, by vulnerability class, our team discovered bugs in 4 out of 8 different classes and patched bugs in 2 of them. Interestingly, we were the only team who found a bug in the Linux kernel challenge, which we&rsquo;re quite proud of, especially for the kernel fuzzing team, which I was a part of. However, on the flip side, our CRS completely failed to do anything on 1 or 2 challenges, which was the crucial factor that guided our mindset in the AFC.</p>
<h3 id="our-mindset">Our Mindset</h3>
<p>Stepping into the AFC from the ASC, the biggest lesson we learned is that we need more testing - <strong>a LOT</strong> more. From triaging the logs from ASC, we realized that we didn&rsquo;t score at all in some challenges not because our CRS lacked efficacy, but simply because there were errors during the building process of CPs that we hadn&rsquo;t tested before. Those errors caused the CRS to fall over and stop working altogether on those targets, which is a really scary situation. The ASC only had 5 CPs across 1 day - we didn&rsquo;t know the exact scale of the AFC final round back then, but we expected it to be much larger, which meant the risk of the CRS falling over was even greater.</p>
<p>Therefore, since the beginning of development for the AFC, our mentor - Dr. Xinyu Xing - had been advocating for testing and stability above all. His philosophy was not to try coming up with fancy new things, but to stick to things that we <em>know</em> would work, and make them as stable as possible. There were obviously disagreements along the way - we are a team of researchers, and many of us wanted to do stuff that was new and special. However, in the end, we chose to stick with the principle of <em>Keep It Simple &amp; Stable</em>. I can&rsquo;t say for sure whether this was the correct choice, but it was a logical decision given the format of the competition. To keep a system running autonomously over 10 days without human intervention at all - the worst thing that could happen is that our CRS falls over 2–3 days into the final round, and we definitely didn&rsquo;t want that.</p>
<p>That being said, at the end of development, the CRS didn&rsquo;t end up <em>that</em> simple. There were so many finer details and features we needed to implement, and performance issues we had to handle, which bloated the size of our CRS by a significant amount. It makes me feel that even with the amount of testing we did, there&rsquo;s no guarantee our CRS won&rsquo;t fall over - which is terrifying to think about!</p>
<h3 id="our-crs">Our CRS</h3>
<p>Now let&rsquo;s get a bit technical and talk about our CRS in more detail. Our CRS is called <strong>BugBuster</strong>. It is a system of many interconnected components, each component performing a <em>specific job</em>, deployed as a <strong>Kubernetes</strong> cluster. The CRS is designed to scale up and down, with many crucial components being <em>scalable both vertically and horizontally</em>. We deploy our system on 32-core nodes on Azure. Components can scale vertically with parallel threads to make full use of these CPU cores, or horizontally by launching many replicas, depending on the number of concurrent tasks at any point in time.</p>
<p>The pipeline of how the components work together is quite complicated, with many parallelizations and dependencies, but I&rsquo;ll try to explain it as clearly as possible at a high-level view. When our CRS receives a new task, the following things happen:</p>
<ol>
<li>The <strong>gateway</strong> receives the task and stores the task information and tarballs in our <strong>PostgreSQL database</strong>.</li>
<li>The <strong>scheduler</strong> acknowledges the existence of new tasks in the database and prepares jobs to send to other components through <strong>RabbitMQ message queues</strong>.</li>
<li>The <strong>fuzzers</strong> are among the first components to receive a job. We have 3 different kinds of fuzzers in our CRS:
<ul>
<li>The <strong>b3fuzz</strong> fuzzers, which are C-specific fuzzers that use customized and optimized strategies for fuzzing. This is our largest-scale fuzzer.</li>
<li>The <strong>prime</strong> fuzzers, which run OSS-Fuzz&rsquo;s libFuzzer to handle both C and Java targets.</li>
<li>The <strong>directed</strong> fuzzers, which handle delta-scan tasks by guiding the fuzzers to the functions presented in the delta diffs.</li>
</ul>
</li>
<li>The <strong>seedgen</strong> component receives a job in parallel to the fuzzers. This is the first component in our CRS that makes use of LLM. It is an LLM agent that analyzes the CPs&rsquo; entrypoints and codebases to write Python scripts that can generate fuzzing seeds. The seeds are generated with the goal of maximizing coverage, using 3 different seedgen strategies (Full, Mini, MCP) to ensure efficacy in both time and diversity.</li>
<li>The <strong>corpus grabber</strong> component also receives a job at this stage. This component doesn&rsquo;t generate seeds but instead <em>grabs</em> seeds from a set of <em>pre-built corpora</em> that we&rsquo;ve created by collecting PoCs of public vulnerabilities in the past for OSS-Fuzz-compatible projects. To take it a step further, we also divided these collected corpora by file types or data types. In cases where a project is brand new and we have no corpus for it, a lightweight LLM agent will analyze the project&rsquo;s entry points and determine which file types or data types of corpus we should grab for it.</li>
<li>During fuzzing, the massive scale of our fuzzer system can generate an overwhelming number of seeds. Therefore, our <strong>cmin</strong> component runs in parallel with fuzzing and periodically minimizes the set of seeds based on coverage. The fuzzers grab the minimized seeds from the <strong>shared storage</strong> whenever they&rsquo;re available.</li>
<li>In order to guide directed fuzzing, our directed fuzzers send a job to our <strong>slicing</strong> component, which utilizes static analysis techniques to generate slices of call paths from entrypoints to target functions. The directed fuzzers use these slices for targeted instrumentation.</li>
<li>Whenever a crash is found, the fuzzers save the PoCs in shared storage and their related information in the database. The <strong>triage</strong> component receives these PoCs and tries to reproduce them. This serves two purposes: to remove FP crashes introduced by fuzzers and to deduplicate PoCs of the same bug into <strong>bug profiles</strong>. We use a naive and conservative deduplication strategy here, based only on crash sites and sanitizer bug types. Because our fuzzers are massively scaled, the number of PoCs generated is enormous. Therefore, our triage replicas are executed massively in parallel as well.</li>
<li>Whenever a bug profile is found, the <strong>patch agent</strong> component kicks in and attempts to fix it. This is the second place where we utilize LLM. We run multiple replicas of the patch agent at a time, each looking at a single crash report for a single bug profile and attempting to fix it. When a patch is found, a DIFF patch will be saved to the database.</li>
<li>Since duplicated patch submissions are penalized for accuracy, we have 2 extra patch-related components, namely <strong>patch reproducer</strong> and <strong>patch submitter</strong>, to perform deduplication. Our deduplication strategy is to test a patch of each bug profile against the PoCs of <em>other</em> bug profiles. The details are complicated for certain edge cases, but basically, if two patches of two different profiles can fix the PoCs of each other, we consider these two bug profiles as duplicates, and these two patches as duplicates, and only choose to submit one of them.</li>
<li>When a SARIF report is received, the gateway saves it into the database, and the scheduler sends a job to the <strong>sarif</strong> component. This component first checks if the bug described in the SARIF report is one we already found. If it isn&rsquo;t, the component does some sanity checks about the validity and reachability of the code area shown in the report, then asks LLM about the correctness of it.</li>
<li>Finally, the <strong>submitter</strong> component periodically looks at the bug profiles, chosen patches, and SARIF assessments in the database in order to submit them and bundle them accordingly.</li>
</ol>
<h3 id="the-experience">The Experience</h3>
<p>The shape of our CRS at the start of development was definitely not identical to the one I describe above. It was a lot simpler, but every time an issue showed up or a change in the rule set was made, we had to adjust accordingly and add in new features to accommodate. As far as I can recall, these are the most significant changes we needed to make.</p>
<p><strong>Exhibition round 1</strong> was our first opportunity to test the CRS at a scale way larger than our test setup, and with that, a lot of issues arose:</p>
<ul>
<li>Our <strong>b3fuzz</strong> fuzzers stopped working halfway because the seed set became too large, and it took forever just to compress and decompress them. That&rsquo;s why we had to implement the seed minimizer <strong>cmin</strong> component.</li>
<li>Our <strong>triage</strong> replicas couldn&rsquo;t keep up with the pace at which fuzzers produced crashes. Therefore, we needed to implement many performance optimization strategies for triaging.</li>
<li>Our <strong>slicing</strong> component for C projects didn&rsquo;t work on a specific case because there was some code written in a newer C standard (C23) in the delta diff. Our slicing was written in LLVM 14, which couldn&rsquo;t compile such code. As a result, we needed to re-implement slicing in LLVM 18 - which sounds simple, but is actually a huge can of worms in itself. The introduction of <em>opaque pointers</em> since LLVM 16 directly affected our technique of creating call graphs, which required coming up with a whole new technique to do so.</li>
</ul>
<p><strong>Exhibition round 2</strong> was another step up in scaling, which unfortunately created more issues:</p>
<ul>
<li>Our <strong>cmin</strong> was originally based on <code>afl-cmin</code>, which was no longer fast enough and failed to minimize the seeds within the given time interval. We needed to come up with our own seed minimizing algorithm to solve it.</li>
<li>We started to hit LLM rate limits within <strong>patch agent</strong> and <strong>seedgen</strong>, which required us to be more mindful of how we allocate LLM usage across components and the number of replicas that could be run in parallel at a time.</li>
<li>We found many duplicated bug profiles of the same root cause this time around, so we started to have discussions about doing PoV deduplication. We tried using the organizer&rsquo;s call stack matching deduplication and an LLM based deduplicator agent. Both methods yielded FPs (putting 2 bug profiles of 2 different root causes as the same bug), so at the end, we kept the naive and conservative deduplication for PoVs and focus on deduplication for patches instead.</li>
<li>At this point, our CRS was still <em>statically</em> scaled, which we realized was no longer a good idea. Therefore, we had to learn how to do dynamic scaling with Azure&rsquo;s infrastructure, and decide which components should be dynamically scaled and the metrics to scale them with.</li>
<li>We started to question our choice of using <strong>RabbitMQ</strong> as our piping system, since we observed some crashes on the RabbitMQ side due to overloaded usage, which caused interruptions in some components. We discussed different architectures to potentially switch to. Ultimately, we decided to still stick with RabbitMQ and made each component handle queue-based errors more gracefully instead.</li>
</ul>
<p>We managed to have an <em>almost</em> complete system after <strong>exhibition round 3</strong> that we could be happy with. However, this was when the final rulings about duplications and AM were announced. To handle the gamesmanship of it, we came up with the <strong>patch reproducer</strong> and <strong>patch submitter</strong> to optimize our scoring strategies. These were implemented very close to the final round submission deadline, which was a nightmare for testing.</p>
<p>Aside from all of that, there were multiple hiccups throughout the 3 rounds as well. Every time the organizers modified things such as the rules, the competition/CRS APIs, the base Docker image they used for OSS-Fuzz, the way they built the CPs&rsquo; Docker images, etc., it would certainly cause some problems in our pipeline that required a day or two to fix. These were especially frustrating, since they had nothing to do with the main features of the CRS and just wasted our development and testing time and budget.</p>
<h3 id="testing">Testing</h3>
<p>As I&rsquo;ve mentioned before, our principle for the AFC was to keep everything stable. To do so, we started testing our systems very early on - as soon as possible. Even before the organizer gave us the integration test repo and a test API, we had already begun building our own test dataset based on the single exemplar challenge they provided for <code>libpng</code>.</p>
<p>Our dataset was prepared using real-world Open Source Vulnerabilities (OSVs) for OSS-Fuzz-compatible projects. We initially collected a large number of them and gathered around 200+ bugs across 80+ projects. However, not all of them were usable for various reasons:</p>
<ul>
<li>Some projects were actually C++, even though their <code>project.yaml</code> file in OSS-Fuzz listed C.</li>
<li>Some projects could only be built using the source code shipped with OSS-Fuzz, not local ones - which we needed to do for AIxCC.</li>
<li>Some failed to build using the AIxCC-customized OSS-Fuzz base images.</li>
<li>Some delta diff files made changes only in build scripts instead of source code.</li>
</ul>
<p>As a result, our final dataset included around 40 projects and 80 bugs, in addition to the official challenges from the exhibition rounds. We continuously ran tests in parallel with development to catch any breaking bugs that could occur at any time.</p>
<p>Since I was the main tester, I can definitely share more about the challenges we faced during testing:</p>
<ul>
<li>Because we were running tests in parallel with development, every time a new feature was pushed, we had to decide whether to restart testing. Most of the time, we chose to restart - which caused testing to be very fragmented. Our CRS was rarely tested continuously for a long duration.</li>
<li>We didn&rsquo;t have good logging or debugging early on, so I had to manually inspect each component&rsquo;s output and notify the authors whenever something looked off.</li>
<li>Since each component had its own author(s), I often couldn&rsquo;t tell if something was a bug unless there was a clear error message. Bugs without obvious symptoms (e.g., misconfigurations that caused a component to underperform) could go unnoticed for a long time.</li>
<li>In the earlier stages, integrity bugs showed up so frequently that we barely had time to evaluate efficacy. Every time I tried to run an efficacy test, a breaking bug would appear, forcing us to fix and re-test - just for another one to appear&hellip;</li>
</ul>
<p>Fortunately, in the later stages, we managed to get every component author on board with testing. Along with a better logging system, this allowed us to conduct more thorough testing - albeit a little later than I would have liked.</p>
<h2 id="peeking-into-other-teams-crss">Peeking into other Teams&rsquo; CRSs</h2>
<p>After the final submission was over and before the winner announcement, thanks to the efforts of Dr. Adam Doupé (<a href="https://x.com/adamdoupe" target="_blank" rel="noopener noreffer ">@adamdoupe</a>) and Dr. Yan Shoshitaishvili (<a href="https://x.com/Zardus" target="_blank" rel="noopener noreffer ">@Zardus</a>) at <a href="https://x.com/ctfradiooo" target="_blank" rel="noopener noreffer ">CTF Radiooo</a>, every team had a chance to join a podcast interview and share their experiences as well as some details of their CRSs. Watching the interviews was a fascinating and eye-opening experience for me. Truthfully, there are so many more ideas I want to explore further now after watching them than when I was developing our CRS. Again, kudos to CTF Radiooo and the participating teams for such insightful discussions!</p>
<p>In this section, I&rsquo;d like to discuss what other teams have achieved that I find interesting, similarly or differently to us, based on their sharings. Please go watch the interviews themselves to get the full context!</p>
<p><strong>VERY IMPORTANT: Keep in mind that these are MY OWN takeaways from watching the podcasts. I might be completely off the mark on some of it, so please don&rsquo;t take what I say at face value. If any other teams have read this and found any errors, please let me know so that I can correct them.</strong> I&rsquo;d love to see how many of these points I got right or wrong after the CRSs are open-sourced.</p>
<h3 id="categories-of-crss">Categories of CRSs</h3>
<p>Overall, I would categorize the CRSs based on their usage of LLM:</p>
<ol>
<li>Some CRSs follow the traditional fuzzing pipeline, with the assistance of LLMs on certain tasks - this category fits our BugBuster CRS.</li>
<li>Some CRSs still follow the fuzzing pipeline but make heavier use of LLM in specific components.</li>
<li>Some CRSs follow an LLM-first approach, with their system mainly running on LLM agents, while fuzzing plays a more supportive role.</li>
</ol>
<p>The variety of approaches to this competition is surprising to me and my team. We originally thought that all CRSs would follow the same shape and didn&rsquo;t believe that an LLM-first approach would be effective. However, it seems we were proven very wrong on this.</p>
<h3 id="trail-of-bits---buttercup">Trail of Bits - ButterCup</h3>
<p>The CRS that I think is closest to ours is <strong>Trail of Bits&rsquo;s ButterCup</strong>. The similarities here are twofold. Firstly, about the overall <strong>architecture</strong>: ButterCup is also a system of multiple components that handle specific jobs, connected with message queues and a database. The jobs are distributed by an <em>orchestrator</em> component, similar to our <em>scheduler</em>. Secondly, there is a similarity in the <strong>mindset</strong>: based on their long-time research and engineering knowledge and experience, Trail of Bits also decided to use LLMs only on tasks they believed LLMs are good at, namely seed generation and patching. This aligns with the belief we had when developing our CRS as well.</p>
<p>That is not to say our CRSs are <em>identical</em>. There are distinct differences where I think Trail of Bits have done things differently and possibly superior to us:</p>
<ul>
<li>Their orchestrator performs both task distribution and submission; we have two separate components for this.</li>
<li>Their seedgen component generates seeds not only based on coverage, but also based on the grammar of commonly seen vulnerabilities.</li>
<li>Their approach to fuzzing, SARIF assessment, and deduplication seems simpler than ours.</li>
<li>Most importantly, they have <strong>much better engineering discipline and experience than us</strong>. The way they have a CI that runs an end-to-end task every time a change is made, and cross-check each other&rsquo;s code before merging, is what I dreamed of as the tester of our team.</li>
</ul>
<h3 id="lacrosse">Lacrosse</h3>
<p>Personally, I think the architecture of <strong>Lacrosse</strong>&rsquo;s CRS is the most unique among the teams, but it still fits in category 1 because of their LLM usage.</p>
<p>They also have a single central node (scheduler/orchestrator) that distributes tasks to others. However, the other nodes here are not specialized task handlers. They all run the same piece of code that can handle any task but choose which task to handle based on a priority system decided by the central node. The worker nodes only communicate with the central node, not with each other. I think this is a very interesting strategy since it saves the headache of maintaining a complex piping interconnectivity system between components, although I can definitely see it introduces more headache in synchronization.</p>
<p>Lacrosse uses LLM mainly for three tasks: vulnerability characterization, patching, and SARIF assessment. The vulnerability characterization is the interesting bit for me. This agent generates a natural language description, assigns a CWE, and suggests which files the root cause of the bug could be in. This information is used as context for patching, and as a way to do PoV deduplication.</p>
<p>Moreover, they have a vertical fallback system between different LLM models in case a model fails or hits rate limits, and a horizontal consensus system to make decisions based on answers from multiple different LLMs. In our team, we thought of these strategies but never implemented them. However, I think they could be valuable to improve stability and accuracy.</p>
<h3 id="shellphish---artiphishell">Shellphish - Artiphishell</h3>
<p>The next CRS I&rsquo;d like to discuss falls into category 2 in my definition, which are CRSs that still follow the traditional pipeline but have heavy usage of LLM in a very specific task.</p>
<p>Architecturally, <strong>Artiphishell</strong> has WAY more specialized components than us, and it&rsquo;s actually pretty intimidating to look at. However, one specific component was emphasized in their podcast as their main secret sauce: the <strong>GrammarGuy</strong>. This is an LLM agent that consumes a huge amount of LLM budget to incrementally scan the entire codebase, accumulating more and more context along the way, to generate grammar for fuzzers.</p>
<p>I&rsquo;m not a fuzzing expert - in fact, I don&rsquo;t know much about fuzzing beyond just running default fuzzers. However, according to my teammates who have done much fuzzing research, traditional grammar-based fuzzing historically proved to be not so effective. I wonder if, with massive LLM usage, grammar-based fuzzing could break through and become the new state-of-the-art? That said, after looking at the official challenges from the exhibition rounds, there are a few vulnerabilities that only trigger if the payload contains certain strings such as <code>&quot;verysimpleprotocol&quot;</code>, <code>&quot;crashycrashy&quot;</code>, or <code>&quot;eMezilaireseD&quot;</code>, etc., which would be likely to work in favor of grammar-based techniques.</p>
<h3 id="team-atlanta---atlantis">Team Atlanta - Atlantis</h3>
<p>If Shellphish uses LLM heavily to aid fuzzing, then Team Atlanta does so to aid patching. <strong>Atlantis</strong> is the only CRS consisting of a fine-tuned LLM model.</p>
<p>They used <em>instruction tuning</em> to fine-tune a Llama model to learn from existing codebases how to decide which appropriate context should be given to patching (e.g., symbols, etc.). This model is then used in a <em>contextualizer</em> agent for their patching component. I don&rsquo;t know much about fine-tuning, but from my recent experiments, having a contextualizer improves patching success rate significantly. For our patch agent in the final round, we only gave it tools to view code at certain lines and locate symbols, which I think could be lacking compared to other teams who used more advanced static analysis or LLM sub-agents as contextualizers for patching. It&rsquo;s definitely interesting to see how effective this fine-tuned LLM contextualizer agent would turn out to be.</p>
<p>Aside from fine-tuning LLM, Team Atlanta also put a lot of efforts in improving and fail-proofing the fuzzing pipeline. Their system has 3 separate sub-CRSs running individually in parallel for C, Java, and Multi-language. Each of the fuzzers in these sub-CRSs are enhanced with <em>customized extensions and instrumentations</em> to the original fuzzers such as libFuzzer, AFL, and JAZZER. This way, each sub-CRS has its own strength, but in case one of them falls over, the others might still be able to finish the job, which is great for stability and reliability.</p>
<h3 id="theori---roboduck">Theori - RoboDuck</h3>
<p>The final two CRSs in the list adopted an LLM-first approach, with <strong>RoboDuck</strong> being my favorite of all among the CRSs in terms of innovation. I was amazed listening to Theori&rsquo;s team members describe their system, because before that, I wouldn&rsquo;t have thought any of their approach would be possible or effective at all. As a team, we played it safe with our system and focused on stability instead of innovative research, but I personally think that an LLM-first system is what DARPA is really looking for.</p>
<p>Architecturally, their system consists of a single Python process that distributes tasks to other nodes, which spawn Docker containers to handle the tasks. Most importantly, these task handlers are almost entirely <strong>LLM agents</strong>, with lots of hand-crafted tools, sub-agents, and guardrails. The philosophy behind the design of these agents is to try not to give them access to terminals or the ability to read code line-by-line, but to provide information through hand-coded tools instead.</p>
<p>There are various &ldquo;sub-agents&rdquo; in the system, which act as tools for the main agents to use, such as:</p>
<ul>
<li><strong>Source code question</strong>: has access to the codebase and answers any source code related questions. To my understanding, this is effectively RoboDuck&rsquo;s contextualizer.</li>
<li><strong>Debugger question</strong>: has access to gdb/jdb and answers any questions that require the CP to be dynamically executed.</li>
<li><strong>Harness input encoder</strong>: analyzes the harness and generates a Python function that takes semantically meaningful arguments and encodes them into the binary format that the fuzzing harness expects.</li>
<li><strong>Harness input decoder</strong>: the opposite of the encoder - generates a Python function to decode a blob of binary input into structured Python objects.</li>
<li>etc.</li>
</ul>
<p>When a challenge task is received, their pipeline is as follows:</p>
<ul>
<li>It starts from <strong>static analyzers</strong> (e.g., Infer), together with an <strong>LLM diff analyzer</strong> for delta tasks, to identify candidate vulnerabilities. There are a lot of false positives at this stage.</li>
<li>They reduce false positives using a lightweight <strong>LLM binary classifier</strong>, which answers with a single token output and bases its decision on the probability of the next YES/NO token to reduce the number of candidate vulnerabilities.</li>
<li>Next is a <strong>Vuln Analyzer agent</strong>, which assesses if a bug is real and reachable, and annotates it with additional information, such as root cause and conditions required to trigger it. As they claim, after this stage, there is a very low false positive rate coming out of this agent (roughly 50% compared to 99.99% from static analyzers).</li>
<li>The <strong>PoV producer agent</strong> and the <strong>Patching agent</strong> are next in line and run in parallel. The PoV producer agent does NOT have access to the codebase and makes use of information retrieved from three sub-agents: source code question, debugger question, and harness input encoder. It generates a Python script to generate PoVs. During the lifetime of a PoV producer agent session, any <em>failed PoVs are used as seeds for the fuzzers</em>. Observably, LLM might just miss a crash by a byte or two that fuzzers can mutate and trigger.</li>
<li>The Patching agent is not very complex and makes use of the harness input decoder agent to make small diff patches. Erroneous diffs are fixed and sanity checked by sequence alignment and dynamic programming approaches.</li>
</ul>
<p>Overall, I find it very fascinating how their system works, and I can&rsquo;t wait to learn all the details from its source code and see it in action!</p>
<h3 id="all-you-need-is-a-fuzzing-brain">All You Need Is A Fuzzing Brain</h3>
<p>Despite their name, this is the second team to adopt an LLM-first approach. According to their explanations, the <strong>&ldquo;fuzzing brain&rdquo;</strong> is an LLM!</p>
<p>Overall, I believe this CRS has many similarities to RoboDuck, with some identical ideas such as using an LLM agent to generate a PoV generator script and using the failed PoVs as seeds for fuzzers. However, they didn&rsquo;t go as in-depth into the agents within their system as Theori did in their interview. On the other hand, similar to Lacrosse, this team also implemented a vertical fallback and horizontal consensus between LLM models.</p>
<p>In addition to LLM, there are two points that they emphasized: advanced static analysis and parallelization. As far as I understand, CodeQL is extensively used in their CRS for reachability analysis. This is how they reduce false positives in candidate vulnerabilities. With an LLM agent, they rank the candidates, and only the top five ranked candidates are fed into other LLM agents for further analysis. They also optimized their CodeQL queries so that this static analysis phase must finish within five minutes.</p>
<p>During the early stages of the ASC, our team also dipped our toes into writing CodeQL. The results, however, were nowhere near as good as we expected - the false positive rate was too high, the analyses were too restricted, and the performance was quite slow. Therefore, I&rsquo;m very interested to see how this team wrote their queries and how well they work.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As I write this, it&rsquo;s about 12 hours until the final results are announced. No matter the outcome, huge thanks to <strong>DARPA</strong> and <strong>ARPA-H</strong> for organizing the AIxCC competition, to my team <strong>42-b3yond-6ug</strong> for the incredible journey, and to <strong>CTF Radiooo</strong> and all the other participating teams for the insightful discussions and knowledge sharing. We&rsquo;ve learned so much together as a team - and I&rsquo;ve grown a lot personally too. These are lessons I never would&rsquo;ve gained just from taking courses or doing research.</p>
<p>When we were asked on the podcast what we would&rsquo;ve done differently, I remember saying that nothing really came to mind. But after some reflection - and after listening to other teams - I&rsquo;ve realized where we can improve. Stability is important, but there&rsquo;s definitely room for us to explore more innovative ideas. And when it comes to engineering discipline, we&rsquo;ve got a long way to go. That&rsquo;s something I want to work on not just as a team member, but individually too.</p>
<p>And finally, to you readers - if you&rsquo;ve made it this far, thank you so much! It feels great to be writing again after two long years.</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2025-08-07</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://lkmidas.github.io/posts/20250808-aixcc-recap/" data-title="Two-year Recap: A Story of 42-b3yond-6ug and AIxCC" data-via="_lkmidas"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://lkmidas.github.io/posts/20250808-aixcc-recap/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://lkmidas.github.io/posts/20250808-aixcc-recap/" data-title="Two-year Recap: A Story of 42-b3yond-6ug and AIxCC"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://lkmidas.github.io/posts/20250808-aixcc-recap/" data-title="Two-year Recap: A Story of 42-b3yond-6ug and AIxCC"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://lkmidas.github.io/posts/20250808-aixcc-recap/" data-title="Two-year Recap: A Story of 42-b3yond-6ug and AIxCC"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/20230828-sekaictf2023-writeups/" class="prev" rel="prev" title="SekaiCTF 2023 Solana Challenge The Bidding Write-up"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>SekaiCTF 2023 Solana Challenge The Bidding Write-up</a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.110.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank"></a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":60},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-HGQHGNF9HJ');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-HGQHGNF9HJ" async></script></body>
</html>
